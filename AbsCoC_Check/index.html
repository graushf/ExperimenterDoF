<html>


<head>
	<title>3D Scene Test Bokeh DoF </title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

	<!--<script type="text/javascript" src="glMatrix-0.9.5-modified.min.js"></script>-->
    <link rel="stylesheet" href="styles.css" type="text/css">
    <script type="text/javascript" src="StatsInformation.js"></script>
	<script type="text/javascript" src="webgl-utils.js"></script>
	<script type="text/javascript" src="gl-matrix-test.js"></script>
    <script type="text/javascript" src="basicSceneObjects.js"></script>

    <script id="lighting-phong-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vFragPos;
        varying vec3 vNormal;
        varying vec2 vTextureCoord;

        uniform vec3 staticColor;

        uniform vec3 lightPos;
        uniform vec3 viewPos;
        uniform vec3 lightColor;
        //uniform vec3 objectColor;

        uniform int uUseTexture;

        uniform int uDisableLighting;

        struct Material {
            sampler2D diffuse;
            float shininess;
            int hasSpecular;
        };

        struct DirLight {
            vec3 direction;

            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
        };

        struct PointLight {
            vec3 position;

            float constant;
            float linear;
            float quadratic;

            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
        };
        #define NR_POINT_LIGHTS 1
        uniform PointLight pointLights[NR_POINT_LIGHTS];

        uniform DirLight dirLight;
        uniform Material material;



        vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);
        vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);

        void main()  
        {   
            vec3 result = staticColor;
            if(uDisableLighting == 0) 
            {
                vec3 norm = normalize(vNormal);
                vec3 lightDir = normalize(lightPos - vFragPos);
                vec3 viewDir = normalize(viewPos - vFragPos);
            
                result = vec3(0.0, 0.0, 0.0);
                result += CalcDirLight(dirLight, norm, viewDir);

                for (int i = 0; i < NR_POINT_LIGHTS; i++) {
                    result += CalcPointLight(pointLights[i], norm, vFragPos, viewDir);
                }
            } 
            
            gl_FragColor = vec4(result, 1.0);
        }

        vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir) {
            vec3 lightDir = normalize(-light.direction);
            // diffuse shading
            float diff = max(dot(normal, lightDir), 0.0);
            // specular shading 
            vec3 reflectDir = reflect(-lightDir, normal);
            float spec = 0.0;
            if (material.hasSpecular == 1) {
                spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);    
            }
            
            // combine results
            vec3 ambient;
            vec3 diffuse;

            if (uUseTexture == 1) {
                ambient = light.ambient * vec3(texture2D(material.diffuse, vTextureCoord));
                diffuse = light.diffuse * diff * vec3(texture2D(material.diffuse, vTextureCoord));    
            } else {
                ambient = light.ambient * light.diffuse;
                diffuse = light.diffuse * diff * light.diffuse;    
            }
           
            vec3 specular = light.specular * spec * light.diffuse;

            return (ambient + diffuse + specular);
            //return specular;
        }

        vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir) {
            vec3 lightDir = normalize(light.position - fragPos);
            // diffuse shading
            float diff = max(dot(normal, lightDir), 0.0);
            // specular shading
            vec3 reflectDir = reflect(-lightDir, normal);
            float spec = 0.0;
            if (material.hasSpecular == 1) {
                spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
            }
            // attenuation
            float distance = length(light.position - fragPos);
            float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

            // combine results
            vec3 ambient = light.ambient * lightColor;
            vec3 diffuse = lightColor* diff * lightColor;
            vec3 specular = light.specular * spec * light.diffuse;
            ambient *= attenuation;
            diffuse *= attenuation;
            specular *= attenuation;
            return (diffuse + specular);
            //return vec3(0.0, 1.0, 0.0);
            //return ambient;
            //return diffuse;
            //return specular;
        }
    </script>

    <script id="lighting-phong-vs" type="x-shader/x-vertex">
       attribute vec3 aVertexPosition;
       attribute vec3 aVertexNormal;
       attribute vec2 aTextureCoord;

       varying vec3 vNormal;
       varying vec3 vFragPos;
       varying vec2 vTextureCoord;

       uniform mat4 uMMatrix;
       uniform mat4 uVMatrix;
       uniform mat4 uPMatrix;
       //uniform mat3 uNMatrix;

       void main(void)  {
            gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
            //gl_Position = vec4(aVertexPosition, 1.0);
            vFragPos = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
            vTextureCoord = aTextureCoord;
            vNormal = aVertexNormal;
       }

    </script>

	<script id="fragment-focal-plane-fs" type="x-shader/x-fragment">
		precision mediump float;

		void main(void) {
			gl_FragColor = vec4(1.0, 1.0, 0.0, 0.5);
		}
	</script>

	<script id="fragment-focal-plane-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;

		uniform mat4 uMMatrix;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;

		void main(void) {
			gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		}
	</script>

	<script id="fragment-depth-fs" type="x-shader/x-fragment">
		precision mediump float;

		uniform float uNear;
		uniform float uFar;

		float LinearizeDepth(float depth) 
		{
			float z = depth * 2.0 - 1.0; // back to NDC
			return (2.0 * uNear * uFar) / (uFar + uNear - z * (uFar - uNear));
		}

		void main(void) {
			float depth = LinearizeDepth(gl_FragCoord.z) / uFar; // divide by far for demostration
			gl_FragColor = vec4(vec3(depth), 1.0);
			//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
	</script>

	<script id="fragment-depth-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;

		uniform mat4 uMMatrix;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;

		void main(void) {
			gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		}
	</script>

	<script id="focal-depth-fs" type="x-shader/x-fragment">
		precision mediump float;

		uniform float uFar;

		uniform vec3 uCameraFront;
		uniform vec3 uCameraPos;

		uniform float uFDistance;

		varying vec3 vFragPos;

		void main(void) {
			//gl_FragColor = vec4(vec3(1.0, 0.0, 0.0), 1.0); return;
			//gl_FragColor = vec4(vec3(uFDistance/uFar), 1.0); return;
			vec3 colorOut = vec3(0.0, 1.0, 0.0);
			vec3 cameraFront = normalize(uCameraFront);

			vec3 v_proj = (dot(vFragPos, cameraFront)/dot(cameraFront, cameraFront))*cameraFront;
			//float d_proj = length(cameraFront-v_proj);
			vec3 v_fragPosCam = vFragPos - uCameraPos;
			float d_proj = dot(cameraFront, v_fragPosCam);


			// Calculation 1
			float aux = d_proj/uFDistance;

			if (aux < 1.0) {
				float color = 1.0 - aux;
				colorOut = vec3(color);
			} else {

				aux = (d_proj - uFDistance)/(uFar - uFDistance);
				colorOut = vec3(aux);
				//colorOut = vec3(1.0, 0.0, 0.0);
			}

			gl_FragColor = vec4(vec3(d_proj)/uFDistance, 1.0);
			gl_FragColor = vec4(colorOut, 1.0);
		}
	</script>

	<script id="focal-depth-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;

	uniform mat4 uMMatrix;
	uniform mat4 uVMatrix;
	uniform mat4 uPMatrix;

	varying vec3 vFragPos;

	void main(void) {
		gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		vFragPos = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
	}
	</script>

    <script id="depth-objectspace-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform float uFar;
        uniform float uNear;

        void main(void) {
            float z = uNear * uFar / (uFar - gl_FragCoord.z*(uFar - uNear));
            float scaleFactor = 100.0;
            z /= scaleFactor;
            gl_FragColor = vec4(vec3(z), 1.0);
            //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
    </script>

    <script id="depth-objectspace-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;

        uniform mat4 uMMatrix;
        uniform mat4 uVMatrix;
        uniform mat4 uPMatrix;

        void main(void) {
            gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>

    <script id="debug-shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vTransformedNormal;
        varying vec4 vPosition;

        void main(void) {
            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
    </script>

    <script id="debug-shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;

        uniform mat4 uMMatrix;
        uniform mat4 uVMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        varying vec3 vTransformedNormal;
        varying vec4 vPosition;

        void main(void) {
            vPosition = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
            gl_Position = uPMatrix * vPosition;
            vTransformedNormal = uNMatrix * aVertexNormal;
        }
    </script>

	

	<script id="shader-vs-postprocess" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec2 aTextureCoord;

		varying vec2 vTextureCoord;

		void main(void) {
			vTextureCoord = aTextureCoord;
			gl_Position = vec4(aVertexPosition, 1.0);
		}

	</script>

    <script id="rend-to-texture-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;

        uniform sampler2D uSampler;

        uniform int uDrawBorder;

        uniform float drawCoC;

        uniform float normColor;

        uniform float multiplyColor;

        void main(void) {
            if (uDrawBorder == 0) {
                vec3 vSample = texture2D(uSampler, vTextureCoord).rgb;
                gl_FragColor = vec4(vSample, 1.0);

                if (drawCoC != 0.0) {

                    float col = texture2D(uSampler, vTextureCoord).w;
                    if (col < 0.0) {
                        gl_FragColor = vec4(abs(col), 0.0, 0.0, 1.0);
                    } 
                    else
                    {
                        gl_FragColor = vec4(0.0, 0.0, col, 1.0);
                    }

                    gl_FragColor *= multiplyColor;
                    return;
                }

                if (normColor == 1.0) {
                    vSample /= 2.0;
                    gl_FragColor = vec4(vSample, 1.0); return;
                }

            } else {
                gl_FragColor = vec4(0.46, 0.71, 0.0, 1.0);
            }
            
        }

    </script>

    <script id="rend-to-texture-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        varying vec2 vTextureCoord;

        uniform mat4 model;

        void main(void) {
            vTextureCoord = aTextureCoord;
            gl_Position = model * vec4(aVertexPosition, 1.0);
        }
    </script>

    <script id="BlurPass1" type="x-shader/x-fragment">
        #extension GL_EXT_draw_buffers : require

        precision mediump float;

        uniform sampler2D uSampler;
        uniform float bokehStrength;
        uniform vec2 uResolution;
        varying vec2 vTextureCoord;

        uniform float uTime;

        //#define USE_RANDOM 

        const int NUM_SAMPLES = 32;

        float OneOverScreenWidth;
        float OneOverScreenHeight;

        float GatherAndApply(vec2 uv, float baseCoC, vec4 currCol, float stepDistance, inout vec4 outColor);
        float hash12n(vec2 p);

        void main() {
            OneOverScreenWidth = 1.0/uResolution.x;
            OneOverScreenHeight = 1.0/uResolution.y;

            vec4 baseColour = texture2D(uSampler, vTextureCoord);

            vec4 outputColor = vec4(0.0, 0.0, 0.0, baseColour.w);
            vec4 outputColor2 = vec4(0.0, 0.0, 0.0, baseColour.w);

            float sampleCount0 = 0.0;
            float sampleCount1 = 0.0;

            // Diagonal blur step, corrector for aspect ratio
            float xStep = 0.866 * (OneOverScreenWidth/OneOverScreenHeight);

            for (int i = 0; i < NUM_SAMPLES; i++)
            {
                float stepDistance = (float(i) + 0.5) * OneOverScreenHeight * bokehStrength;

                // Vertical blur.
                vec2 step0 = vec2(0.0, -1.0) * stepDistance;
                sampleCount0 += GatherAndApply(vTextureCoord + step0, baseColour.w, outputColor, stepDistance, outputColor);

                // Diagonal blur
                vec2 step1 = vec2(xStep, 0.5) * stepDistance;
                sampleCount1 += GatherAndApply(vTextureCoord + step1, baseColour.w, outputColor2, stepDistance, outputColor2);
            }

            //Normalize if any color was added. 
            outputColor.xyz = sampleCount0 > 0.0 ? (outputColor.xyz / sampleCount0) : baseColour.xyz;
            outputColor2.xyz = sampleCount1 > 0.0 ? (outputColor2.xyz / sampleCount1) : baseColour.xyz;

            // The second render target contains both of these added together. Don't divide 
            // by two here, as it'll be combined again and divided by three in the next pass.
            outputColor2.xyz += outputColor.xyz;

            //gl_FragData[0] = vec4(0.90, 0.73, 0.039, 1.0);
            //gl_FragData[1] = vec4(0.92, 0.47, 0.92, 1.0);

            // For the combined term, set the CoC to the blurriest of the two inputs
            if (abs(outputColor.w) > abs(outputColor2.w))
            {
                outputColor2.w = outputColor.w;
            }

            // Debug
            //outputColor.w = -0.7;
            //outputColor2.w = -0.7;
            //outputColor = texture2D(uSampler, vTextureCoord);
            //outputColor2 = texture2D(uSampler, vTextureCoord);

            gl_FragData[0] = outputColor;
            gl_FragData[1] = outputColor2;

            //gl_FragData[0] = vec4(outputColor.xyz, 1.0);
            //gl_FragData[1] = vec4(outputColor2.xyz, 1.0);
        }

        float GatherAndApply(vec2 uv, float baseCoC, vec4 currCol, float stepDistance, inout vec4 outColor) {
            
            outColor = currCol;
            vec4 col = texture2D(uSampler, uv);

            float sampleFraction = 0.0;

            // CoC < 0 means the pixel is in front of the focal plane.
            bool blurNear = col.w < 0.0;
            float absCoC = abs(col.w);
            
            //Check if the CoC of the sampled pixel is big enough to scatter here, and 
            //the sampled pixel is in front of the focal plane or
            //this pixel is behind the focal plane and the sampled pixel isn't too far behind it.
            if ((absCoC > stepDistance) && (blurNear || (baseCoC > 0.0 && absCoC < baseCoC * 2.0)))
            {
                // Sort out the CoC of the blurred image, by taking the biggest CoC to maintain the 
                // hexagon shape in the second pass.
                // Near-blurred pixels should continue to blur over far pixels. Far pixels don't blur
                // over near pixels so that case can be ignored.
                if (blurNear) {
                    if (outColor.w < 0.0)
                    {
                        // This pixel is already near-blurred, so see if the sampled CoC is any bigger.
                        outColor.w = min(outColor.w, col.w);
                    } 
                    else 
                    {
                        // This pixel is behind the focal plane, so only continue with the near-blur if 
                        // that is stronger. Going to get artifacts either way on depth edges with different
                        // coloured pixels.
                        if (-col.w > outColor.w)
                        {
                            outColor.w = col.w;
                        }
                    }
                }

                // Now accumulate the colour. Allow partial sampling at the pixel boundary for smootheness. 
                float sampleFraction = clamp((absCoC - stepDistance) / OneOverScreenHeight, 0.0, 1.0);
                outColor.xyz += sampleFraction * col.xyz;

                return sampleFraction;
            }

            // float sampleFraction = clamp((absCoC - stepDistance) / OneOverScreenHeight, 0.0, 1.0);
            // outColor.xyz += sampleFraction * col.xyz;
            // return sampleFraction;

            // No colour added.
            return 0.0;
        }

        // note: uniform pdf ranf [0;1[
        float hash12n(vec2 p) 
        {
            p = fract(p * vec2(5.3987, 5.4421));
            p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));
            return fract(p.x * p.y * 95.4307);
        }
    </script>

    <script id="BlurPass2" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D BlurPass1_0;
        uniform sampler2D BlurPass1_1;

        uniform float bokehStrength;

        uniform vec2 uResolution;
        varying vec2 vTextureCoord;

        uniform float uTime;

        uniform float drawFirstBlur;
        uniform float drawFirstBlurCoC;
        uniform float drawSecondBlur;
        uniform float drawSecondBlurCoC;

        uniform float multiplyColor;

        //#define USE_RANDOM 

        const int NUM_SAMPLES = 32;

        float OneOverScreenWidth;
        float OneOverScreenHeight;

        float GatherAndApply(sampler2D texture, vec2 uv, float baseCoC, vec4 currCol, float stepDistance, inout vec4 outColor);
        float hash12n(vec2 p);

        void main(void) {
            vec4 finalCol;

            vec4 baseColour = texture2D(BlurPass1_1, vTextureCoord);
            // Two sets of colour to accumulate this time.
            vec4 outputColor0 = vec4(0.0, 0.0, 0.0, baseColour.w);
            vec4 outputColor1 = vec4(0.0, 0.0, 0.0, baseColour.w);

            OneOverScreenWidth = 1.0/uResolution.x;
            OneOverScreenHeight = 1.0/uResolution.y;

            float sampleCount0 = 0.0;
            float sampleCount1 = 0.0;

            // Diagonal passes in different directions for each input texture
            float xStep = 0.866 * (OneOverScreenWidth/OneOverScreenHeight);
            vec2 step0 = vec2(xStep, 0.5);
            vec2 step1 = vec2(-xStep, 0.5);

            for (int i = 0; i < NUM_SAMPLES; i++)
            {
                float stepDistance = (float(i) + 0.5) * OneOverScreenHeight * bokehStrength;

                sampleCount0 += GatherAndApply(BlurPass1_0, vTextureCoord + step0 * stepDistance, baseColour.w, outputColor0, stepDistance, outputColor0);
                sampleCount1 += GatherAndApply(BlurPass1_1, vTextureCoord + step1 * stepDistance, baseColour.w, outputColor1, stepDistance, outputColor1);
            }

            // Normalize if any color was added. col0 is from sampling the single texture,
            // so use half the base colour (which is from the combined texture)
            outputColor0.xyz = sampleCount0 > 0.0 ? outputColor0.xyz / sampleCount0 : vec3(1.0, 1.0, 0.0);
            outputColor1.xyz = sampleCount1 > 0.0 ? outputColor1.xyz / sampleCount1 : vec3(0.0, 0.0, 1.0);

            if (drawFirstBlur != 0.0) {
                //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); return;
                //gl_FragColor = vec4(texture2D(BlurPass1_0, vTextureCoord).xyz, 1.0); return;
                gl_FragColor = vec4(outputColor0.xyz, 1.0); return;
            }
            if (drawFirstBlurCoC != 0.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); 
                float col = texture2D(BlurPass1_0, vTextureCoord).w; 
                if (col < 0.0) {
                    gl_FragColor = vec4(abs(col), 0.0, 0.0, 1.0);
                }
                else {
                    gl_FragColor = vec4(0.0, 0.0, col, 1.0);
                }
                gl_FragColor *= multiplyColor;
                return;
            }
            if (drawSecondBlur != 0.0) {
                //gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0); return;
                //gl_FragColor = vec4(texture2D(BlurPass1_1, vTextureCoord).xyz, 1.0); return;
                gl_FragColor = vec4(outputColor1.xyz/2.0, 1.0); return;
            }
            if (drawSecondBlurCoC != 0.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); 
                float col = texture2D(BlurPass1_1, vTextureCoord).w; 
                if (col < 0.0) {
                    gl_FragColor = vec4(abs(col), 0.0, 0.0, 1.0);
                }
                else {
                    gl_FragColor = vec4(0.0, 0.0, col, 1.0);
                }
                gl_FragColor *= multiplyColor;
                return;
            }


            // Combine and divide by three (col1 is double brightness)
            finalCol.xyz = (outputColor0.xyz + outputColor1.xyz) / 3.0;
            //finalCol.xyz = outputColor1.xyz;
            // Use a max for the blurriness, no accumulation done here.
            finalCol.w = max(abs(outputColor0.w), abs(outputColor1.w));
            //finalCol.w = 1.0;

            //gl_FragColor = vec4(finalCol.xyz, 1.0);
            gl_FragColor = finalCol;
        }

        float GatherAndApply(sampler2D texture, vec2 uv, float baseCoC, vec4 currCol, float stepDistance, inout vec4 outColor) {

            float sampleFraction = 0.0;
            outColor = currCol;
            vec4 col = texture2D(texture, uv);
            // CoC < 0 means the pixel is in front of the focal plane.
            bool blurNear = col.w < 0.0;
            float absCoC = abs(col.w);

            //Check if the CoC of the sampled pixel is big enough to scatter here, and 
            //the sampled pixel is in front of the focal plane or
            //this pixel is behind the focal plane and the sampled pixel isn't too far behind it.
            if ((absCoC > stepDistance) && (blurNear || (baseCoC > 0.0 && absCoC < baseCoC * 2.0)))
            {
                // Sort out the CoC of the blurred image, by taking the biggest CoC to maintain the 
                // hexagon shape in the second pass.
                // Near-blurred pixels should continue to blur over far pixels. Far pixels don't blur
                // over near pixels so that case can be ignored.
                if (blurNear) {
                    if (outColor.w < 0.0)
                    {
                        // This pixels is already near-blurred, so see if the sampled CoC is any bigger
                        outColor.w = min(outColor.w, col.w);
                    }
                    else {
                        // This pixel is behind the focal plane, so only continue with the near-blur if 
                        // that is stronger. Going to get artifacts either way on depth edges with different
                        // coloured pixels.
                        if (-col.w > outColor.w)
                        {
                            outColor.w = col.w;
                        }
                    }
                }

                // Now accumulate the colour. Allow partial sampling at the pixel boundary for smoothness
                float sampleFraction = clamp((absCoC - stepDistance) / OneOverScreenHeight, 0.0, 1.0);
                outColor.xyz += sampleFraction * col.xyz;

                return sampleFraction;
            }

            //float sampleFraction = clamp((absCoC - stepDistance) / OneOverScreenHeight, 0.0, 1.0);
            //outColor.xyz += sampleFraction * col.xyz;
            //return sampleFraction;

            // No colour added
            return 0.0;
        }

        // note: uniform pdf ranf [0;1[
        float hash12n(vec2 p) 
        {
            p = fract(p * vec2(5.3987, 5.4421));
            p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));
            return fract(p.x * p.y * 95.4307);
        }

    </script>

    <script id="DepthPass-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform float uFar;
        uniform float uNear;

        void main(void) {
            float z = gl_FragCoord.z;
            //float z = uNear * uFar / (uFar - gl_FragCoord.z*(uFar - uNear));
            gl_FragColor = vec4(vec3(z), 1.0);
        }
    </script>

    <script id="DepthPass-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform mat4 uMMatrix;
        uniform mat4 uVMatrix;
        uniform mat4 uPMatrix;

        void main(void) {
            gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>

    <script id="CoCSizePass-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D colorChannel;
        uniform sampler2D depthChannel;

        uniform float CoCScale;
        uniform float CoCBias;

        varying vec2 vTextureCoord;

        void main(void) {
            //gl_FragColor = texture2D(depthChannel, vTextureCoord); return;

            //gl_FragColor = texture2D(depthChannel, vTextureCoord); return;
            vec4 outCol;

            outCol.xyz = texture2D(colorChannel, vTextureCoord).xyz;

            outCol.w = texture2D(depthChannel, vTextureCoord).x;
            float aux = texture2D(depthChannel, vTextureCoord).x;

            // Get CoCScale and CoCBias from aperture, focal length, focal plane and 
            // cam near/far, as per equations
            outCol.w = (CoCScale * outCol.w) + CoCBias; //Implementation Purple Space
            //outCol.w = -0.5;
            //outCol.w = abs(outCol.w * CoCScale + CoCBias); Dice Paper
            //outCol.w = outCol.w * CoCScale  + 0.0;
            gl_FragColor = outCol;
            //gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
            //gl_FragColor = vec4(outCol.w, 0.0, 0.0, 1.0);
            //gl_FragColor = vec4(aux, 0.0, 0.0, 1.0);
        }
    </script>

    <script id="DebugCoC-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;

        uniform sampler2D inputChannel;

        uniform int uDrawBorder;

        void main(void) {

            gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
            if (uDrawBorder == 0) {
                float col = texture2D(inputChannel, vTextureCoord).w;
                if (col < 0.0) {
                    gl_FragColor = vec4(abs(col), 0.0, 0.0, 1.0);
                } 
                else
                {
                    gl_FragColor = vec4(0.0, 0.0, col, 1.0);
                }
                // } else if {
                //     gl_FragColor = vec4(0.0, 0.0, col, 1.0);
                // }
                //gl_FragColor = vec4(col, col, col, 1.0);
                
                //gl_FragColor = vec4(col, col, col, 1.0);

                gl_FragColor.xyz *= 50.0;
                
            } else {
                gl_FragColor = vec4(0.46, 0.71, 0.0, 1.0);
            }
        }

    </script>


    <script id="CoCSizePass-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        varying vec2 vTextureCoord;

        void main(void) {
            vTextureCoord = aTextureCoord;
            gl_Position = vec4(aVertexPosition, 1.0);
        }        
    </script>

    <script id="ApplyDoFPass-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;

        uniform sampler2D uChannelOriginalScene;
        uniform sampler2D uChannelBluredScene;

        void main(void) {
            // Sample the texture
            vec4 colChannel0 = texture2D(uChannelOriginalScene, vTextureCoord);
            vec4 colChannel1 = texture2D(uChannelBluredScene, vTextureCoord);

            //gl_FragColor = vec4(colChannel1.www, 1.0); return;

            // Blur texture is lower resolution so only blend it in if the pixel
            // is out of focus. Use a nice blend to avoid an obvious boundary
            colChannel1.w = clamp(1000.0 * abs(colChannel1.w) - 0.001, 0.0, 1.0);

            vec4 finalCol = mix(colChannel0, colChannel1, colChannel1.w);
            //gl_FragColor = vec4(colChannel1.xyz, 1.0); return;
            gl_FragColor = finalCol;
            //gl_FragColor = texture2D(uChannelOriginalScene, vTextureCoord);
            //gl_FragColor = texture2D(uChannelBluredScene, vTextureCoord);
            //gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
    </script>

    <script id="DebugPass-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D uSampler;
        uniform float bokehStrength;
        uniform vec2 uResolution;
        varying vec2 vTextureCoord;

        uniform float uTime;

        //#define USE_RANDOM 

        const int NUM_SAMPLES = 32;

        float OneOverScreenWidth;
        float OneOverScreenHeight;

        float GatherAndApply(vec2 uv, float baseCoC, vec4 currCol, float stepDistance, inout vec4 outColor);
        float hash12n(vec2 p);

        void main() {
            OneOverScreenWidth = 1.0/uResolution.x;
            OneOverScreenHeight = 1.0/uResolution.y;

            vec4 baseColour = texture2D(uSampler, vTextureCoord);

            vec4 outputColor = vec4(0.0, 0.0, 0.0, baseColour.w);
            vec4 outputColor2 = vec4(0.0, 0.0, 0.0, baseColour.w);

            float sampleCount0 = 0.0;
            float sampleCount1 = 0.0;

            // Diagonal blur step, corrector for aspect ratio
            float xStep = 0.866 * (OneOverScreenWidth/OneOverScreenHeight);

            for (int i = 0; i < NUM_SAMPLES; i++)
            {
                float stepDistance = (float(i) + 0.5) * OneOverScreenHeight * bokehStrength;

                // Vertical blur.
                vec2 step0 = vec2(0.0, -1.0) * stepDistance;
                #if defined(USE_RANDOM) 
                    //step0 += (hash12n(step0 + fract(uTime)/1000.0+0.001)) * 1.0;
                    step0 += (hash12n(step0/100000000.0)) * 1.0;
                #endif
                sampleCount0 += GatherAndApply(vTextureCoord + step0, baseColour.w, outputColor, stepDistance, outputColor);

                vec4 aux = texture2D(uSampler, vTextureCoord);
                bool blurNear = aux.w < 0.0;
                
                if (blurNear) {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
                }
                return;

                // Diagonal blur
                vec2 step1 = vec2(xStep, 0.5) * stepDistance;
                sampleCount1 += GatherAndApply(vTextureCoord + step1, baseColour.w, outputColor2, stepDistance, outputColor2);
            }

            //Normalize if any color was added. 
            outputColor.xyz = sampleCount0 > 0.0 ? (outputColor.xyz / sampleCount0) : baseColour.xyz;
            outputColor2.xyz = sampleCount1 > 0.0 ? (outputColor2.xyz / sampleCount1) : baseColour.xyz;

            // The second render target contains both of these added together. Don't divide 
            // by two here, as it'll be combined again and divided by three in the next pass.
            outputColor2.xyz += outputColor.xyz;

            // For the combined term, set the CoC to the blurriest of the two inputs
            if (abs(outputColor.w) > abs(outputColor2.w))
            {
                outputColor2.w = outputColor.w;
            }

        }

        float GatherAndApply(vec2 uv, float baseCoC, vec4 currCol, float stepDistance, inout vec4 outColor) {
            outColor = currCol;
            vec4 col = texture2D(uSampler, uv);

            // CoC < 0 means the pixel is in front of the focal plane.
            bool blurNear = col.w < 0.0;
            float absCoC = abs(col.w);
            //float absCoC = abs(bokehStrength);

            //Check if the CoC of the sampled pixel is big enough to scatter here, and 
            //the sampled pixel is in front of the focal plane or
            //this pixel is behind the focal plane and the sampled pixel isn't too far behind it.
            if ((absCoC > stepDistance) && (blurNear || (baseCoC > 0.0 && absCoC < baseCoC * 2.0)))
            {
                // Sort out the CoC of the blurred image, by taking the biggest CoC to maintain the 
                // hexagon shape in the second pass.
                // Near-blurred pixels should continue to blur over far pixels. Far pixels don't blur
                // over near pixels so that case can be ignored.
                if (blurNear) {
                    if (outColor.w < 0.0)
                    {
                        // This pixel is already near-blurred, so see if the sampled CoC is any bigger.
                        outColor.w = min(outColor.w, col.w);
                    } 
                    else 
                    {
                        // This pixel is behind the focal plane, so only continue with the near-blur if 
                        // that is stronger. Going to get artifacts either way on depth edges with different
                        // coloured pixels.
                        if (-col.w > outColor.w)
                        {
                            outColor.w = col.w;
                        }
                    }
                }

                // Now accumulate the colour. Allow partial sampling at the pixel boundary for smootheness. 
                float sampleFraction = clamp((absCoC - stepDistance) / OneOverScreenHeight, 0.0, 1.0);
                outColor.xyz += sampleFraction * col.xyz;

                return sampleFraction;
            }

            // float sampleFraction = clamp((absCoC - stepDistance) / OneOverScreenHeight, 0.0, 1.0);
            // outColor.xyz += sampleFraction * col.xyz;
            // return sampleFraction;

            // No colour added.
            return 0.0;
        }

    </script>




	<script type="text/javascript">

		var gl;

		// Camera
		var myCamera;
		var lastX;
		var lastY;
		var firstMouse = true;
		var enableMouse = false;

		// Deltatime
		var deltaTime = 0.0;	// Time between current frame and last frame
		var lastFrame = 0.0;	// Time of last frame

		var distanceFocalPlane = 1000.0;

		var uFocalDistance = 300;

		var textureFramebufferSetupScene;
		var textureFramebufferFocalDepthScene;
		var textureFramebufferBufferABokeh;
		var textureFramebufferBufferBBokeh;
		var textureFramebufferBufferCBokeh;
		var textureFramebufferBufferDBokeh;

        var textureAuxFramebuffer;

		var framebufferSetupSceneRGBA32F;
		var framebufferFocalDepthScene;
		var framebufferBufferABokehRGBA32F;
		var framebufferBufferBBokehRGBA32F;
		var framebufferBufferCBokehRGBA32F;
		var framebufferBufferDBokehRGBA32F;

        var auxFramebufferRGBA32F;


        var framebufferDepth;
        var textureFramebufferDepth;

        var framebufferCoCSize;
        var textureFramebufferCoCSize;


        var framebufferApplyDoFPass;
        var textureFramebufferApplyDoF;


		var screenFillingVertexPositionBuffer;
		var screenFillingTextureCoordBuffer;
		var screenFillingIndexBuffer;

		var elapsed;
        var time_start;

        var bokehStrength = 1.0;


        var lightPos = vec3.fromValues(10.0, 0.0, 0.0);

        var lightPointPos = vec3.fromValues(10.0, 10.0, 15.0);

        var ext3;
        var MRTfbData;

        // var Aperture = 0.1; // 1.0
        // var focalLength = 0.021;
        // var focalPlane = 5.0;

        var Aperture = 2.29; // 1.0 // 0.6 // Old: 0.6 
        var focalLength = 5.52; //Old: 0.021
        var focalPlane = 136.0; //Old: 10.0

        //var _focalPlane = 10.0;
        var _focalPlane = 0.02;

        var CoCScale;
        var CoCBias;

        var farBlurdistancelimit = 2.0;

		function initGL(canvas) {
			try {
				gl = canvas.getContext("experimental-webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			} catch (e) {
			}
			if (!gl) {
				alert("Could not initialise WebGL, sorry :-(");
			}
		}

		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3) {
					str += k.textContent;
				}
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type = "x-shader/x-vertex") {
				shader = gl.createShader(gl.VERTEX_SHADER);
			} else {
				return null;
			}

			gl.shaderSource(shader, str);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert(gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
		}

		
		var shaderProgramFocalPlane;

		function initShadersFocalPlane() {
			var fragmentShader = getShader(gl, "fragment-focal-plane-fs");
			var vertexShader = getShader(gl, "fragment-focal-plane-vs");

			shaderProgramFocalPlane = gl.createProgram();
			gl.attachShader(shaderProgramFocalPlane, vertexShader);
			gl.attachShader(shaderProgramFocalPlane, fragmentShader);
			gl.linkProgram(shaderProgramFocalPlane);

			if (!gl.getProgramParameter(shaderProgramFocalPlane, gl.LINK_STATUS)) {
				alert("Could not initialise shaders");
			}
		}

		var shaderProgramDepth;

		function initShadersDepth() {
			var fragmentShader = getShader(gl, "fragment-depth-fs");
			var vertexShader = getShader(gl, "fragment-depth-vs");

			shaderProgramDepth = gl.createProgram();
			gl.attachShader(shaderProgramDepth, vertexShader);
			gl.attachShader(shaderProgramDepth, fragmentShader);
			gl.linkProgram(shaderProgramDepth);

			if (!gl.getProgramParameter(shaderProgramDepth, gl.LINK_STATUS)) {
				alert("Could not initialise shaders");
			}

			shaderProgramDepth.vertexPositionAttribute = gl.getAttribLocation(shaderProgramDepth, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgramDepth.vertexPositionAttribute);

			shaderProgramDepth.pMatrixUniform = gl.getUniformLocation(shaderProgramDepth, "uPMatrix");
			shaderProgramDepth.modelMatrixUniform = gl.getUniformLocation(shaderProgramDepth, "uMMatrix");
			shaderProgramDepth.viewMatrixUniform = gl.getUniformLocation(shaderProgramDepth, "uVMatrix");

			shaderProgramDepth.nearUniform = gl.getUniformLocation(shaderProgramDepth, "uNear");
			shaderProgramDepth.farUniform = gl.getUniformLocation(shaderProgramDepth, "uFar");
		}

		var shaderProgramFocalDepth;

		function initShadersFocalDepth() {
			var fragmentShader = getShader(gl, "focal-depth-fs");
			var vertexShader = getShader(gl, "focal-depth-vs");

			shaderProgramFocalDepth = gl.createProgram();
			gl.attachShader(shaderProgramFocalDepth, vertexShader);
			gl.attachShader(shaderProgramFocalDepth, fragmentShader);
			gl.linkProgram(shaderProgramFocalDepth);

			if (!gl.getProgramParameter(shaderProgramFocalDepth, gl.LINK_STATUS)) {
				alert("Could not initialise shaders");
			}

			shaderProgramFocalDepth.vertexPositionAttribute = gl.getAttribLocation(shaderProgramFocalDepth, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgramFocalDepth.vertexPositionAttribute);

			shaderProgramFocalDepth.pMatrixUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uPMatrix");
			shaderProgramFocalDepth.modelMatrixUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uMMatrix");
			shaderProgramFocalDepth.viewMatrixUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uVMatrix");

			shaderProgramFocalDepth.farUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uFar");

			shaderProgramFocalDepth.cameraFrontsUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uCameraFront");

			//uCameraPos
			shaderProgramFocalDepth.cameraPosUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uCameraPos");

			shaderProgramFocalDepth.focalDistanceUniform = gl.getUniformLocation(shaderProgramFocalDepth, "uFDistance");
		}

        var shaderProgramDepthObjectSpace; 

        function initShadersDepthObjectSpace() {
            var fragmentShader = getShader(gl, "depth-objectspace-fs");
            var vertexShader = getShader(gl, "depth-objectspace-vs");

            shaderProgramDepthObjectSpace = gl.createProgram();
            gl.attachShader(shaderProgramDepthObjectSpace, vertexShader);
            gl.attachShader(shaderProgramDepthObjectSpace, fragmentShader);
            gl.linkProgram(shaderProgramDepthObjectSpace);

            if (!gl.getProgramParameter(shaderProgramDepthObjectSpace, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramDepthObjectSpace.vertexPositionAttribute = gl.getAttribLocation(
                shaderProgramDepthObjectSpace, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramDepthObjectSpace.vertexPositionAttribute);

            shaderProgramDepthObjectSpace.pMatrixUniform = gl.getUniformLocation(shaderProgramDepthObjectSpace, "uPMatrix");
            shaderProgramDepthObjectSpace.modelMatrixUniform = gl.getUniformLocation(
                shaderProgramDepthObjectSpace, "uMMatrix");
            shaderProgramDepthObjectSpace.viewMatrixUniform = gl.getUniformLocation(
                shaderProgramDepthObjectSpace, "uVMatrix");

            shaderProgramDepthObjectSpace.nearUniform = gl.getUniformLocation(shaderProgramDepthObjectSpace, "uNear");
            shaderProgramDepthObjectSpace.farUniform = gl.getUniformLocation(shaderProgramDepthObjectSpace, "uFar");

        }

        var shaderProgramLightingPhong;
        function initShaderLightingPhong()
        {
            var fragmentShader = getShader(gl, "lighting-phong-fs");
            var vertexShader = getShader(gl, "lighting-phong-vs");

            shaderProgramLightingPhong = gl.createProgram();
            gl.attachShader(shaderProgramLightingPhong, vertexShader);
            gl.attachShader(shaderProgramLightingPhong, fragmentShader);
            gl.linkProgram(shaderProgramLightingPhong);

            if (!gl.getProgramParameter(shaderProgramLightingPhong, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramLightingPhong.vertexPositionAttribute = gl.getAttribLocation(shaderProgramLightingPhong, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramLightingPhong.vertexPositionAttribute);

            shaderProgramLightingPhong.vertexNormalAttribute = gl.getAttribLocation(shaderProgramLightingPhong, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgramLightingPhong.vertexNormalAttribute);


            shaderProgramLightingPhong.textureCoordAttribute = gl.getAttribLocation( shaderProgramLightingPhong, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramLightingPhong.textureCoordAttribute);

            shaderProgramLightingPhong.pMatrixUniform = gl.getUniformLocation(shaderProgramLightingPhong, "uPMatrix");
            shaderProgramLightingPhong.modelMatrixUniform = gl.getUniformLocation(shaderProgramLightingPhong, "uMMatrix");
            shaderProgramLightingPhong.viewMatrixUniform = gl.getUniformLocation( shaderProgramLightingPhong, "uVMatrix");
            //shaderProgramLightingPhong.nMatrixUniform = gl.getUniformLocation(shaderProgramLightingPhong, "uNMatrix");

            //shaderProgramLightingPhong.objectColorUniform = gl.getUniformLocation(shaderProgramLightingPhong, "objectColor");
            shaderProgramLightingPhong.lightColorUniform = gl.getUniformLocation(shaderProgramLightingPhong, "lightColor");
            shaderProgramLightingPhong.lightPosUniform = gl.getUniformLocation(shaderProgramLightingPhong, "lightPos");
            shaderProgramLightingPhong.viewPosUniform = gl.getUniformLocation(shaderProgramLightingPhong, "viewPos"); 
        }

        var shaderProgramBufferRendToText;
        function initShadersRendToText() 
        {
            var fragmentShader = getShader(gl, "rend-to-texture-fs");
            var vertexShader = getShader(gl, "rend-to-texture-vs");

            shaderProgramBufferRendToText = gl.createProgram();
            gl.attachShader(shaderProgramBufferRendToText, vertexShader);
            gl.attachShader(shaderProgramBufferRendToText, fragmentShader);
            gl.linkProgram(shaderProgramBufferRendToText);

            if (!gl.getProgramParameter(shaderProgramBufferRendToText, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }

        var shaderProgramHdrColor;
        function initShadersHdrColor()
        {
            var fragmentShader = getShader(gl, "hdr-color-fs");
            var vertexShader = getShader(gl, "hdr-color-vs");

            shaderProgramHdrColor = gl.createProgram();
            gl.attachShader(shaderProgramHdrColor, vertexShader);
            gl.attachShader(shaderProgramHdrColor, fragmentShader);
            gl.linkProgram(shaderProgramHdrColor);

            if (!gl.getProgramParameter(shaderProgramHdrColor, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramHdrColor.vertexPositionAttribute = gl.getAttribLocation(shaderProgramHdrColor, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramHdrColor.vertexPositionAttribute);

            shaderProgramHdrColor.pMatrixUniform = gl.getUniformLocation(shaderProgramHdrColor, "uPMatrix");
            shaderProgramHdrColor.modelMatrixUniform = gl.getUniformLocation(shaderProgramHdrColor, "uMMatrix");
            shaderProgramHdrColor.viweMatrixUniform = gl.getUniformLocation(shaderProgramHdrColor, "uVMatrix");
        }

        var shaderProgramFirstPassBlur;
        function initShadersFirstPassBlur() {
            var fragmentShader = getShader(gl, "BlurPass1");
            var vertexShader = getShader(gl, "shader-vs-postprocess");

            shaderProgramFirstPassBlur = gl.createProgram();
            gl.attachShader(shaderProgramFirstPassBlur, vertexShader);
            gl.attachShader(shaderProgramFirstPassBlur, fragmentShader);
            gl.linkProgram(shaderProgramFirstPassBlur);

            if (!gl.getProgramParameter(shaderProgramFirstPassBlur, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }

        var shaderProgramSecondPassBlur;
        function initShadersSecondPassBlur() {
            var fragmentShader = getShader(gl, "BlurPass2");
            var vertexShader = getShader(gl, "shader-vs-postprocess");

            shaderProgramSecondPassBlur = gl.createProgram();
            gl.attachShader(shaderProgramSecondPassBlur, vertexShader);
            gl.attachShader(shaderProgramSecondPassBlur, fragmentShader);
            gl.linkProgram(shaderProgramSecondPassBlur);

            if (!gl.getProgramParameter(shaderProgramSecondPassBlur, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }

        var shaderProgramDepthPass;
        function initShadersDepthPass() {
            var fragmentShader = getShader(gl, "DepthPass-fs");
            var vertexShader = getShader(gl, "DepthPass-vs");

            shaderProgramDepthPass = gl.createProgram();
            gl.attachShader(shaderProgramDepthPass, vertexShader);
            gl.attachShader(shaderProgramDepthPass, fragmentShader);
            gl.linkProgram(shaderProgramDepthPass);

            if (!gl.getProgramParameter(shaderProgramDepthPass, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramDepthPass.vertexPositionAttribute = gl.getAttribLocation(
                shaderProgramDepthPass, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramDepthPass.vertexPositionAttribute);

            shaderProgramDepthPass.pMatrixUniform = gl.getUniformLocation(shaderProgramDepthPass, "uPMatrix");
            shaderProgramDepthPass.modelMatrixUniform = gl.getUniformLocation(
                shaderProgramDepthPass, "uMMatrix");
            shaderProgramDepthPass.viewMatrixUniform = gl.getUniformLocation(
                shaderProgramDepthPass, "uVMatrix");
        }

        var shaderProgramCoCSizePass;
        function initShadersCoCSizePass() {
            var fragmentShader = getShader(gl, "CoCSizePass-fs");
            var vertexShader = getShader(gl, "CoCSizePass-vs");

            shaderProgramCoCSizePass = gl.createProgram();
            gl.attachShader(shaderProgramCoCSizePass, vertexShader);
            gl.attachShader(shaderProgramCoCSizePass, fragmentShader);
            gl.linkProgram(shaderProgramCoCSizePass);

            if (!gl.getProgramParameter(shaderProgramCoCSizePass, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }

        var shaderProgramApplyDoFPass;
        function initShadersApplyDoFPass() {
            var fragmentShader = getShader(gl, "ApplyDoFPass-fs");
            var vertexShader = getShader(gl, "shader-vs-postprocess");

            shaderProgramApplyDoFPass = gl.createProgram();
            gl.attachShader(shaderProgramApplyDoFPass, vertexShader);
            gl.attachShader(shaderProgramApplyDoFPass, fragmentShader);
            gl.linkProgram(shaderProgramApplyDoFPass);

            if (!gl.getProgramParameter(shaderProgramApplyDoFPass, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }


        var shaderProgramDebugCoC;
        function initShadersDebugCoC() {
            var fragmentShader = getShader(gl,"DebugCoC-fs");
            var vertexShader = getShader(gl, "rend-to-texture-vs");

            shaderProgramDebugCoC = gl.createProgram();
            gl.attachShader(shaderProgramDebugCoC, vertexShader);
            gl.attachShader(shaderProgramDebugCoC, fragmentShader);
            gl.linkProgram(shaderProgramDebugCoC);

            if (!gl.getProgramParameter(shaderProgramDebugCoC, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }


        var shaderProgramDebugPass1;
        //DebugPass-fs
        function initShadersDebugPass1() {
            var fragmentShader = getShader(gl, "DebugPass-fs");
            var vertexShader = getShader(gl, "shader-vs-postprocess");

            shaderProgramDebugPass1 = gl.createProgram();
            gl.attachShader(shaderProgramDebugPass1, vertexShader);
            gl.attachShader(shaderProgramDebugPass1, fragmentShader);
            gl.linkProgram(shaderProgramDebugPass1);

            if (!gl.getProgramParameter(shaderProgramDebugPass1, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }
        }

		function handleLoadedTexture(texture) {
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			//gl.generateMipmap(gl.TEXTURE_2D);

			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		function isPowerOf2(value) {
            return (value & (value - 1)) == 0;
        }

		function loadTexture(url) {
            const texture = gl.createTexture();
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Because images have to be downloaded over the internet
            // they might take a moment until they are ready.
            // Until then put a single pixel in the texture so we can 
            // use it immediately. When the image has finished downloading
            // we'll update the texture with the contents of the image.
            const level = 0;
            const internalFormal = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormal, width, height, border, srcFormat, srcType, pixel);

            const image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormal, srcFormat, srcType, image);

                // WebGL1 has different requirements for power of 2 images
                // vs non power of 2 images so check if the image is a 
                // power of 2 in both dimensions
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    // No, it's not a power of 2. Turn of mips and set
                    // wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            };
            image.src = url;

            return texture;
        }

        function Camera3D() {
        	// Camera attributes
        	this.Position = [];
        	this.Front = [];
        	this.Up = [];
        	this.Right = [];
        	this.WorldUp = [];
        	// Euler Angles
        	this.Yaw = [];
        	this.Pitch = [];
        	// Camera options
        	this.MovementSpeed = [];
        	this.MouseSensitivity = [];
        	this.Zoom = [];
        	this.screenWIDTH = [];
        	this.screenHEIGHT = [];
        	// DEFAULT VALUES
        	this.YAW = -90.0;
        	this.PITCH = 0.0;
        	this.SPEED = 10.0;
        	this.SENSITIVITY = 0.25;
        	this.ZOOM = 45.0;
        	this.SCROLLSENSITIVITY = 0.05;

        	this.Near = 0.1;
        	this.Far = 8000;

        	this.Camera = function(WIDTH, HEIGHT) {
        		var position = vec3.create();
        		var up = vec3.create(0.0, 1.0, 0.0);
        		var yaw = this.YAW;
        		var pitch = this.PITCH;
        		this.Front = vec3.fromValues(0.0, 0.0, -1.0);
        		this.MovementSpeed = this.SPEED;
        		this.MouseSensitivity = this.SENSITIVITY;
        		this.Zoom = this.ZOOM;
        		this.Position = position;
        		this.WorldUp = up;
        		this.Yaw = yaw;
        		this.Pitch = pitch;
        		this.screenWIDTH = WIDTH;
        		this.screenHEIGHT = HEIGHT;
        		this.updateCameraVectors();
        	},

        	this.CameraSetPos = function(position, WIDTH, HEIGHT) {
        		var up = vec3.fromValues(0.0, 1.0, 0.0);
        		var yaw = this.YAW;
        		var pitch = this.PITCH;
        		this.Front = vec3.fromValues(0.0, 0.0, -1.0);
        		this.MovementSpeed = this.SPEED;
        		this.MouseSensitivity = this.SENSITIVITY;
        		this.Zoom = this.ZOOM;
        		this.Position = position;
        		this.WorldUp = up;
        		this.Yaw = yaw;
        		this.Pitch = pitch;
        		this.screenWIDTH = WIDTH;
        		this.screenHEIGHT = HEIGHT;
        		this.updateCameraVectors();
        	},

        	this.Camera = function(position, up, yaw, pitch, WIDTH, HEIGHT) {
        		this.Front = vec3.fromValues(0.0, 0.0, -1.0);
        		this.MovementSpeed = this.SPEED;
        		this.MouseSensitivity = this.SENSITIVITY;
        		this.Zoom = this.ZOOM;
        		this.Position = position;
        		this.WorldUp = up;
        		this.Yaw = yaw;
        		this.Pitch = pitch;
        		this.screenWIDTH = WIDTH;
        		this.screenHEIGHT = HEIGHT;
        		this.updateCameraVectors();
        	},

        	this.Camera = function(posX, posY, posZ, upX, upY, upZ, yaw, pitch, WIDTH, HEIGHT) {
        		this.Front = vec3.fromValues(0.0, 0.0, -1.0);
        		this.MovementSpeed = this.SPEED;
        		this.MouseSensitivity = this.SENSITIVITY;
        		this.Zoom = this.ZOOM;
        		this.Position = vec3.fromValues(posX, posY, posZ);
        		this.WorldUp = vec3.fromValues(upX, upY, upZ);
        		this.Yaw = yaw;
        		this.Pitch = pitch;
        		this.screenWIDTH = WIDTH;
        		this.screenHEIGHT = HEIGHT;
        		this.updateCameraVectors();
        	},

        	this.GetViewMatrix = function() {
        		var retMat = mat4.create();
        		var center = vec3.create();
        		vec3.add(center, this.Position, this.Front);

        		mat4.lookAt(retMat, this.Position, center, this.Up);
        		return retMat;
        	},

        	this.GetProjectionMatrix = function() {
        		var pPatrix = mat4.create();
				mat4.perspective(pMatrix, this.convertToRadians(45), this.screenWIDTH/this.screenHEIGHT, this.Near, this.Far);
				return pMatrix;
				
        	},

        	this.ProcessKeyboard = function(direction, deltaTime) {
        		var velocity = this.MovementSpeed * deltaTime;
        		// FORWARD DIRECTION
        		if (direction == 0) {
        			var aux = vec3.fromValues(this.Front[0] * velocity, this.Front[1] * velocity, this.Front[2] * velocity);
        			vec3.add(this.Position, this.Position, aux);
        		}
        		// BACKWARD DIRECTION
        		if (direction == 1) {
        			var aux = vec3.fromValues(-1 * this.Front[0] * velocity, -1 * this.Front[1] * velocity, -1 * this.Front[2] * velocity);
        			vec3.add(this.Position, this.Position, aux);
        		}
        		// LEFT DIRECTION
        		if (direction == 2) {
        			var aux = vec3.fromValues(-1 * this.Right[0] * velocity, -1 * this.Right[1] * velocity, -1 * this.Right[2] * velocity);
        			vec3.add(this.Position, this.Position, aux);
        		}
        		// RIGHT DIRECTION
        		if (direction == 3) {
        			var aux = vec3.fromValues(this.Right[0] * velocity, this.Right[1] * velocity, this.Right[2] * velocity);
        			vec3.add(this.Position, this.Position, aux);
        		}
        	},

        	this.ProcessMouseMovement = function(xoffset, yoffset, constrainPitch) {
        		constrainPitch = true;
        		xoffset = this.MouseSensitivity * xoffset;
        		yoffset = this.MouseSensitivity * yoffset;

        		this.Yaw = this.Yaw + xoffset;
        		this.Pitch = this.Pitch + yoffset;

        		// Make sure that when pitch is out of bounds, screen doesn't get flipped
        		if (constrainPitch) {
        			if (this.Pitch > 89.0) {
        				this.Pitch = 89.0;
        			}
        			if (this.Pitch < -89.0) {
        				this.Pitch = -89.0;
        			}
        		}
        		// Update Front, Right and Up vectors using the updater Euler Angles
        		this.updateCameraVectors();
        	},

        	this.ProcessMouseScroll = function(yoffset) {
        		if (this.Zoom >= 1.0 && this.Zoom <= 45.0) {
        			this.Zoom -= yoffset * SCROLLSENSITIVITY;
        		}
        		if (this.Zoom <= 1.0) {
        			this.Zoom = 1.0;
        		}
        		if (this.Zoom >= 45.0) {
        			this.Zoom = 45.0;
        		}
        	},

        	this.convertToRadians = function(degrees) {
        		return (degrees * (0.01745329251994329576923690768489));
        	}

        	this.updateCameraVectors = function() {
        		// Calculate the new Front vector
        		var front = vec3.create();
        		front[0] = Math.cos(this.convertToRadians(this.Yaw)) * Math.cos(this.convertToRadians(this.Pitch));
        		front[1] = Math.sin(this.convertToRadians(this.Pitch));
        		front[2] = Math.sin(this.convertToRadians(this.Yaw)) * Math.cos(this.convertToRadians(this.Pitch));
        		var _aux = vec3.create();
        		vec3.normalize(this.Front, front);
        		// Also re-calculate the Right and Up Vectors
        		// Normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.
        		var aux = vec3.create();
        		vec3.cross(aux, this.Front, this.WorldUp);
        		vec3.normalize(this.Right, aux);
        		aux = vec3.create();
        		vec3.cross(aux, this.Right, this.Front);
        		vec3.normalize(this.Up, aux);
        	},

        	this.GetNearValue = function() {
        		return this.Near;
        	},

        	this.GetFarValue = function() {
        		return this.Far;
        	},

            this.SetPositionAndDirectionCamera = function(position, pitch, yaw) {
                this.Position = position;
                this.Yaw = yaw;
                this.Pitch = pitch;
                this.updateCameraVectors();
            }
        }

		var earthTexture;
		var galvanizedTexture;
		var metalsurfaceTexture;

        var bokeh2DTexture;

		function initTextures() {
			galvanizedTexture = loadTexture("http://localhost/POC_DoF_Adv/3D_Scene/nature.jpg");
            //galvanizedTexture = loadTexture("http://localhost/POC_DoF_Adv/3D_Scene/red_texture.jpg");
			metalsurfaceTexture = loadTexture("http://localhost/POC_DoF_Adv/3D_Scene/metal_texture.jpg");
			checkerGrayTexture = loadTexture("http://localhost/POC_DoF_Adv/3D_Scene/checker_grey_pot.jpg");

            bokeh2DTexture = loadTexture("http://localhost/ExperimenterDoF/Optical_Bokeh_DoF/texture_2d_bokeh3.jpg");

            skyTexture = loadTexture("http://localhost/ExperimenterDoF/Optical_BokehMTR_DoF/texture_sky_pot.jpg");
		}

		function createAndSetupTexture() 
	    {
	        var texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, texture);

	        // Set up texture so we can render any size image and so we are working with pixels.
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

	        return texture;                
	    }

		var mMatrix = mat4.create();
		var mvMatrixStack = [];
		var pMatrix = mat4.create();
		var vMatrix = mat4.create();

		function mvPushMatrix() {
			var copy = mat4.create();
			mat4.set(mvMatrix, copy);
			mvMatrixStack.push(copy);
		}

		function mvPopMatrix() {
			if (mvMatrixStack.length == 0) {
				throw "Invalid popMatrix!";
			}
			mvMatrix = mvMatrixStack.pop();
		}

		function setMatrixUniforms(program) {
			gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
			gl.uniformMatrix4fv(program.modelMatrixUniform, false, mMatrix);

			gl.uniformMatrix4fv(program.viewMatrixUniform, false, vMatrix);

			// if (((program == shaderProgram) || (program == shaderProgramDebugObject)) || (program == shaderProgramLightingPhong)) {
			// 	var normalMatrix = mat3.create();
			// 	mat3.normalFromMat4(normalMatrix, mMatrix)
			// 	//mat4.toInverseMat3(mvMatrix, normalMatrix);
			// 	//mat3.transpose(normalMatrix);
			// 	gl.uniformMatrix3fv(program.nMatrixUniform, false, normalMatrix);	
			// }

            if ((program == shaderProgramLightingPhong)) {
                var normalMatrix = mat3.create();
                mat3.normalFromMat4(normalMatrix, mMatrix)
                //mat4.toInverseMat3(mvMatrix, normalMatrix);
                //mat3.transpose(normalMatrix);
                gl.uniformMatrix3fv(program.nMatrixUniform, false, normalMatrix);   
            }

		}

		function degToRad(degrees) {
			return degrees * Math.PI / 180;
		}

		function initScreenFillingBuffers() {
			screenFillingVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
			vertices = [
                 1.0,  1.0,  0.0,
                -1.0,  1.0,  0.0,
                 1.0, -1.0,  0.0,
                -1.0, -1.0,  0.0
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            screenFillingVertexPositionBuffer.itemSize = 3;
            screenFillingVertexPositionBuffer.numItems = 4;

            screenFillingTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            var textureCoords = [
                1.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                0.0, 0.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
            screenFillingTextureCoordBuffer.itemSize = 2;
            screenFillingTextureCoordBuffer.numItems = 4;

            screenFillingIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            var squareVertexIndices = [
                0, 1, 3,    0, 3, 2
            ];
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(squareVertexIndices), gl.STATIC_DRAW);
            screenFillingIndexBuffer.itemSize = 1;
            screenFillingIndexBuffer.numItems = 6;
		}




		var teapotPositionBuffer;
		var teapotVertexNormalBuffer;
		var teapotVertexTextureCoordBuffer;
		var teapotVertexIndexBuffer;

		function handleLoadedTeapot(teapotData) {
			teapotVertexNormalBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
			teapotVertexNormalBuffer.itemSize = 3;
			teapotVertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

			teapotVertexTextureCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexTextureCoords), gl.STATIC_DRAW);
			teapotVertexTextureCoordBuffer.itemSize = 2;
			teapotVertexTextureCoordBuffer.numItems = teapotData.vertexTextureCoords.length / 2;

			teapotVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
			teapotVertexPositionBuffer.itemSize = 3;
			teapotVertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

			teapotVertexIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(teapotData.indices), gl.STATIC_DRAW);
			teapotVertexIndexBuffer.itemSize = 1;
			teapotVertexIndexBuffer.numItems = teapotData.indices.length;

			//document.getElementById("loadingtext").textContent = "";
		}

		function loadTeapot() {
			var request = new XMLHttpRequest();
			request.open("GET", "http://localhost/POC_DoF_Adv/3D_Scene/Teapot.json");
			request.onreadystatechange = function() {
				if (request.readyState == 4) {
					handleLoadedTeapot(JSON.parse(request.responseText));
				}
			}
			request.send();
		}

		var planeVertexPositionBuffer;
		var planeVertexNormalBuffer;
		var planeVertexTextureCoordBuffer;
		var planeVertexIndexBuffer;

		function initBuffersPlane() {
			planeVertexNormalBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
			var normals = [
				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
			planeVertexNormalBuffer.itemSize = 3;
			planeVertexNormalBuffer.numItems = 4;

			planeVertexTextureCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexTextureCoordBuffer);
			var textureCoords = [
				0.0, 0.0,
				10.0, 0.0,
				10.0, 10.0,
				0.0, 10.0
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
			planeVertexTextureCoordBuffer.itemSize = 2;
			planeVertexTextureCoordBuffer.numItems = 4;

			planeVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
			var vertices = [
				-1.0, 0.0, 1.0,
				1.0, 0.0, 1.0,
				1.0, 0.0, -1.0,
				-1.0, 0.0, -1.0
			];
			// var vertices = [
			// 	-1.0, -1.0, 0.0,
			// 	1.0, -1.0, 0.0,
			// 	1.0, 1.0, 0.0,
			// 	-1.0, 1.0, 0.0
			// ];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			planeVertexPositionBuffer.itemSize = 3;
			planeVertexPositionBuffer.numItems = 4;


			planeVertexIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeVertexIndexBuffer);
			var indices = [
				0, 1, 2, 
				0, 2, 3
			];
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
			planeVertexIndexBuffer.itemSize = 1;
			planeVertexIndexBuffer.numItems = 6;
		}

        var sphereVertexPositionBuffer;
        var sphereVertexNormalBuffer;
        var sphereVertexTextureCoordBuffer;
        var sphereVertexIndexBuffer;

        function initBuffersSphere() {
            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphereGeomParams.vertexPositions, gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numItems = sphereGeomParams.vertexPositions.length;


            sphereVertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphereGeomParams.vertexNormals, gl.STATIC_DRAW);
            sphereVertexNormalBuffer.itemSize = 3;
            sphereVertexNormalBuffer.numItems = sphereGeomParams.vertexNormals.length;

            sphereVertexTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphereGeomParams.vertexTextureCoords, gl.STATIC_DRAW);
            sphereVertexTextureCoordBuffer.itemSize = 2;
            sphereVertexTextureCoordBuffer.numItems = sphereGeomParams.vertexTextureCoords.length;

            sphereVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphereGeomParams.indices, gl.STATIC_DRAW);
            sphereVertexIndexBuffer.itemSize = 1;
            sphereVertexIndexBuffer.numItems = sphereGeomParams.indices.length;
        }


		var focalPlaneVertexPositionBuffer;
		var focalPlaneIndexBuffer;

		function initBuffersFocalPlane() {
			focalPlaneVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, focalPlaneVertexPositionBuffer);
			var vertices = [
				-1.0, -1.0, 0.0,
				 1.0, -1.0, 0.0,
				 1.0, 1.0, 0.0,
				 -1.0, 1.0, 0.0
			];

			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			focalPlaneVertexPositionBuffer.itemSize = 3;
			focalPlaneVertexPositionBuffer.numItems = 4;

			focalPlaneIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, focalPlaneIndexBuffer);
			var indices = [
				0, 1, 2,
				0, 2, 3
			];
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
			focalPlaneIndexBuffer.itemSize = 1;
			focalPlaneIndexBuffer.numItems = 6;
		}

		function drawFocalPlane(positionFocalPlane) {
			gl.useProgram(shaderProgramFocalPlane);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.enable(gl.BLEND);
			gl.disable(gl.DEPTH_TEST);


			shaderProgramFocalPlane.vertexPositionAttribute = gl.getAttribLocation(shaderProgramFocalPlane, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgramFocalPlane.vertexPositionAttribute);

			shaderProgramFocalPlane.pMatrixUniform = gl.getUniformLocation(shaderProgramFocalPlane, "uPMatrix");
			shaderProgramFocalPlane.modelMatrixUniform = gl.getUniformLocation(shaderProgramFocalPlane, "uMMatrix");
			shaderProgramFocalPlane.viewMatrixUniform = gl.getUniformLocation(shaderProgramFocalPlane, "uVMatrix");

			pMatrix = myCamera.GetProjectionMatrix();

			mat4.identity(mMatrix);
			vMatrix = myCamera.GetViewMatrix();

			mat4.translate(mMatrix, mMatrix, [positionFocalPlane[0], positionFocalPlane[1], positionFocalPlane[2]]);
			var aux = mat4.create();
			mat4.fromScaling(aux, [100.0, 100.0, 100.0]);
			mat4.multiply(mMatrix, mMatrix, aux);


			gl.bindBuffer(gl.ARRAY_BUFFER, focalPlaneVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgramFocalPlane.vertexPositionAttribute, focalPlaneVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, focalPlaneIndexBuffer);
			setMatrixUniforms(shaderProgramFocalPlane);
			gl.drawElements(gl.TRIANGLES, focalPlaneIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

			gl.disable(gl.BLEND);
			gl.enable(gl.DEPTH_TEST);
		}


		function init3DScene() {
			initBuffersPlane();
			loadTeapot();
			initBuffersFocalPlane();
            initSphereObject();
            initBuffersSphere();
		}

		function initCamera() {
			//Camera : function(position, WIDTH, HEIGHT);
			myCamera = new Camera3D();
			var aux = vec3.fromValues(-13.34, 30.73, 51.12);
			myCamera.CameraSetPos(aux, gl.viewportWidth, gl.viewportHeight);
            var _pos = vec3.fromValues(-9.0000, 15.60, 31.27);
            var _pitch = 13.75;
            var _yaw = -90.0;
            myCamera.SetPositionAndDirectionCamera(_pos, _pitch, _yaw);
			//_pos = vec3.fromValues(0.0, 0.0, 10.0);
            //_pitch = 0.0;
            //_yaw = -90.0;
            //myCamera.SetPositionAndDirectionCamera(_pos, _pitch, _yaw);

            lastX = gl.viewportWidth / 2.0;
			lastY = gl.viewportHeight / 2.0;
			console.log(myCamera);
			console.log("bla");
			//positionFocalPlane = myCamera.Position + 0.0 * myCamera.Front;
		}


		var teapotAngle = 180;


		function drawTeapot(programShading, translatePos) {
			gl.useProgram(programShading);
			//gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			//gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			if (teapotVertexPositionBuffer == null || teapotVertexNormalBuffer == null || teapotVertexTextureCoordBuffer == null || teapotVertexIndexBuffer == null) {
				return;
			}

			pMatrix = myCamera.GetProjectionMatrix();

			// if (programShading == shaderProgram) {
			// 	gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
			// 	gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
			// 	gl.enableVertexAttribArray(programShading.textureCoordAttribute);
			// 	gl.uniform1i(programShading.showSpecularHighlightsUniform, 1);
			// 	var lighting = 1;
			// 	gl.uniform1i(programShading.useLightingUniform, lighting);

			// 	if (lighting) {
			// 		gl.uniform3f(
			// 			programShading.ambientColorUniform,
			// 			0.2, 0.2, 0.2
			// 		);

			// 		gl.uniform3f(
			// 			programShading.pointLightingLocationUniform, 
			// 			-10.0, 4.0, -20.0
			// 		);

			// 		gl.uniform3f(
			// 			programShading.pointLightingSpecularColorUniform,
			// 			0.8, 0.8, 0.8
			// 		);

			// 		gl.uniform3f(
			// 			programShading.pointLightingDiffuseColorUniform,
			// 			0.8, 0.8, 0.8
			// 		);
			// 	}
				
			// 	gl.uniform1i(programShading.useTexturesUniform, 0);	

			// 	gl.activeTexture(gl.TEXTURE0);
			// 	gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
			// 	gl.uniform1i(programShading.samplerUniform, 0);

			// 	gl.uniform1f(programShading.materialShininessUniform, 64.0);

			// 	gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
			// 	gl.vertexAttribPointer(programShading.textureCoordAttribute, teapotVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

			// 	gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
			// 	gl.vertexAttribPointer(programShading.vertexNormalAttribute, teapotVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
			// }
			if (programShading == shaderProgramDepth) {
				gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
				gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
				gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
				gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
				gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
			}
			if (programShading == shaderProgramFocalDepth) {
				gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
				gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
				gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
				gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
				gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
				
				gl.uniform3f(programShading.cameraFrontsUniform, myCamera.Front[0], myCamera.Front[1], myCamera.Front[2]);
				
				gl.uniform3f(programShading.cameraPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

				gl.uniform3f(programShading.focalPlanePosUniform, positionFocalPlane[0], positionFocalPlane[1], positionFocalPlane[2]);

				var aux = vec3.create();
				vec3.scaleAndAdd(aux, myCamera.Position, positionFocalPlane, -1);
				var uFdist = Math.sqrt(vec3.squaredLength(aux));

				gl.uniform1f(programShading.focalDistanceUniform, uFocalDistance);
				//console.log("uFdist: "+uFdist);
			}
            if (programShading == shaderProgramLightingPhong) {
                //console.log("PHONG SHADING");

                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
                gl.enableVertexAttribArray(programShading.textureCoordAttribute);

                gl.uniform3f(programShading.objectColorUniform, 1.0, 0.5, 0.31);
                gl.uniform3f(programShading.lightColorUniform, 1.0, 1.0, 1.0);
                gl.uniform3f(programShading.lightPosUniform, lightPos[0], lightPos[1], lightPos[1]);
                gl.uniform3f(programShading.viewPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

                gl.uniform1i(gl.getUniformLocation(programShading, "uUseTexture"), 1);
                gl.uniform1i(gl.getUniformLocation(programShading, "uDisableLighting"), 0);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.diffuse"), 0);
                gl.uniform1f(gl.getUniformLocation(programShading, "material.shininess"), 64.0);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.hasSpecular"), 1);


                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.direction"), -0.2, -1, -0.3);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.ambient"), 0.05, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.diffuse"), 0.8, 0.8, 0.8);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.specular"), 0.5, 0.5, 0.5);


                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].position"), lightPointPos[0], lightPointPos[1], lightPointPos[2]);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].ambient"), 1.00, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].diffuse"), 100 * 181/255, 20 * 134/255, 20 * 144/255);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].specular"), 5.0, 5.0, 5.0);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].constant"), 1.0);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].linear"), 0.02);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].quadratic"), 0.010);

                gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
                gl.vertexAttribPointer(programShading.vertexNormalAttribute, teapotVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
                gl.vertexAttribPointer(programShading.textureCoordAttribute, teapotVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }
            if (programShading == shaderProgramDepthObjectSpace) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
            }
            if (programShading == shaderProgramDepthPass) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.uniform1f(gl.getUniformLocation(programShading, "uFar"), myCamera.GetFarValue());
                gl.uniform1f(gl.getUniformLocation(programShading, "uNear"), myCamera.GetNearValue());
                //gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                //gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

			mat4.identity(mMatrix);
			mat4.identity(vMatrix);
			vMatrix = myCamera.GetViewMatrix();

			mat4.translate(mMatrix, mMatrix, [translatePos[0], translatePos[1], translatePos[2]]);
			//mat4.rotate(mMatrix, mMatrix, degToRadasaww(23.4), [1, 0, 0]);
			//mat4.rotate(mMatrix, mMatrix, degToRad(teapotAngle), [0, 1, 0]);

			
			gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
			gl.vertexAttribPointer(programShading.vertexPositionAttribute, teapotVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

			
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
			setMatrixUniforms(programShading);
			gl.drawElements(gl.TRIANGLES, teapotVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		}

		function drawPlane(programShading) {
			gl.useProgram(programShading);
			//mat4.perspectiveAlt(45, gl.viewportWidth / gl.viewportHeight, 0.1, 500.0, pMatrix);
			pMatrix = myCamera.GetProjectionMatrix();

			// if (programShading == shaderProgram) {
			// 	gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
			// 	gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
			// 	gl.enableVertexAttribArray(programShading.textureCoordAttribute);

			// 	gl.uniform1i(programShading.showSpecularHighlightsUniform, 1);
			// 	var lighting = 1;
			// 	gl.uniform1i(programShading.useLightingUniform, lighting);

			// 	if (lighting) {
			// 		gl.uniform3f(
			// 			programShading.ambientColorUniform,
			// 			0.2, 0.2, 0.2
			// 		);

			// 		gl.uniform3f(
			// 			programShading.pointLightingLocationUniform, 
			// 			-10.0, 4.0, -20.0
			// 		);

			// 		gl.uniform3f(
			// 			programShading.pointLightingSpecularColorUniform,
			// 			0.8, 0.8, 0.8
			// 		);

			// 		gl.uniform3f(
			// 			programShading.pointLightingDiffuseColorUniform,
			// 			0.8, 0.8, 0.8
			// 		);
			// 	}

			// 	gl.uniform1i(programShading.useTexturesUniform, 1);

			// 	gl.activeTexture(gl.TEXTURE0);
			// 	gl.bindTexture(gl.TEXTURE_2D, checkerGrayTexture);
			// 	gl.uniform1i(programShading.samplerUniform, 0);

			// 	gl.uniform1f(programShading.materialShininessUniform, 32.0);

			// 	gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexTextureCoordBuffer);
			// 	gl.vertexAttribPointer(programShading.textureCoordAttribute, planeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

			// 	gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
			// 	gl.vertexAttribPointer(programShading.vertexNormalAttribute, planeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

			// }
			if (programShading == shaderProgramDepth) {
				gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
				gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
				gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
				gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
				gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
			}
			if (programShading == shaderProgramFocalDepth) {
				gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
				gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
				gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
				gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
				gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
				
				gl.uniform3f(programShading.cameraFrontsUniform, myCamera.Front[0], myCamera.Front[1], myCamera.Front[2]);

				//console.log(myCamera.Position[0]);
				//console.log(myCamera.Position[1]);
				//console.log(myCamera.Position[2]);
				gl.uniform3f(programShading.cameraPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

				gl.uniform3f(programShading.focalPlanePosUniform, positionFocalPlane[0], positionFocalPlane[1], positionFocalPlane[2]);

				var aux = vec3.create();
				var _aux = vec3.create();
				vec3.add(_aux, positionFocalPlane, myCamera.Position);
				vec3.scaleAndAdd(aux, myCamera.Position, _aux, -1);
				var uFdist = Math.sqrt(vec3.squaredLength(aux));
				//console.log(uFdist);
				//console.log(positionFocalPlane);
				gl.uniform1f(programShading.focalDistanceUniform, uFocalDistance);

			}
            if (programShading == shaderProgramLightingPhong) {
                //console.log("PHONG SHADING");

                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
                gl.enableVertexAttribArray(programShading.textureCoordAttribute);

                gl.uniform3f(programShading.objectColorUniform, 1.0, 0.5, 0.31);
                gl.uniform3f(programShading.lightColorUniform, 1.0, 1.0, 1.0);
                gl.uniform3f(programShading.lightPosUniform, lightPos[0], lightPos[1], lightPos[1]);
                gl.uniform3f(programShading.viewPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

                gl.uniform1i(gl.getUniformLocation(programShading, "uUseTexture"), 1);
                gl.uniform1i(gl.getUniformLocation(programShading, "uDisableLighting"), 0);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, checkerGrayTexture);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.diffuse"), 0);
                gl.uniform1f(gl.getUniformLocation(programShading, "material.shininess"), 1.0);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.hasSpecular"), 0);

                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.direction"), -0.2, -1, -0.3);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.ambient"), 0.05, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.diffuse"), 0.8, 0.8, 0.8);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.specular"), 0.5, 0.5, 0.5);

                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].position"), lightPointPos[0], lightPointPos[1], lightPointPos[2]);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].ambient"), 0.05, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].diffuse"), 0.8, 0.8, 0.8);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].specular"), 1.0, 1.0, 1.0);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].constant"), 1.0);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].linear"), 0.09);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].quadratic"), 0.032);


                gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
                gl.vertexAttribPointer(programShading.vertexNormalAttribute, planeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexTextureCoordBuffer);
                gl.vertexAttribPointer(programShading.textureCoordAttribute, planeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }
            if (programShading == shaderProgramDepthObjectSpace) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
            }
            if (programShading == shaderProgramDepthPass) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.uniform1f(gl.getUniformLocation(programShading, "uFar"), myCamera.GetFarValue());
                gl.uniform1f(gl.getUniformLocation(programShading, "uNear"), myCamera.GetNearValue());
                //gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                //gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

			mat4.identity(mMatrix);
			var aux = mat4.create();
			mat4.identity(aux);

			mat4.identity(vMatrix);
			//mat4.translate(vMatrix, vMatrix, [0, 0, -300]);
			vMatrix = myCamera.GetViewMatrix();


			// FIRST MATRIX TRANSFORMS
			//mat4.translate(mvMatrix, [0.0, 0.0, -60]);
			//mat4.rotate(mvMatrix, degToRad(23.4), [1, 1, 1]);
			//mat4.rotate(mvMatrix, degToRad(teapotAngle), [0, 1, 0]);

			// SECOND MATRIX TRANSFORMS
			//mat4.scale(mvMatrix, [2.2, 2.2, 2.2]);
			mat4.translate(mMatrix, mMatrix, [0, 0, -60]);
			//mat4.fromScaling(mvMatrix, [8.2, 8.2, 8.2]); 

			//mat4.translate(mvMatrix, aux, vec3.fromValues(0.5, 0.0, 0.0));
			//mat4.rotate(mMatrix, mMatrix, degToRad(23.4), [1, 0, 0]);
			//dsdwmat4.rotate(mMatrix, mMatrix, degToRad(teapotAngle), [0, 1, 0]);
			//mat4.multiplyScalar(mvMatrix, mvMatrix, [1.0, 1.0, 1.0]);
			mat4.fromScaling(aux, [2000.0, 2000.0, 2000.0]);
			mat4.multiply(mMatrix, mMatrix, aux);

			
			gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
			gl.vertexAttribPointer(programShading.vertexPositionAttribute, planeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

			
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeVertexIndexBuffer);
			setMatrixUniforms(programShading);
			gl.drawElements(gl.TRIANGLES, planeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		}


        function drawPlaneHorizon(programShading) {
            gl.useProgram(programShading);
            //mat4.perspectiveAlt(45, gl.viewportWidth / gl.viewportHeight, 0.1, 500.0, pMatrix);
            pMatrix = myCamera.GetProjectionMatrix();

            // if (programShading == shaderProgram) {
            //  gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
            //  gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
            //  gl.enableVertexAttribArray(programShading.textureCoordAttribute);

            //  gl.uniform1i(programShading.showSpecularHighlightsUniform, 1);
            //  var lighting = 1;
            //  gl.uniform1i(programShading.useLightingUniform, lighting);

            //  if (lighting) {
            //      gl.uniform3f(
            //          programShading.ambientColorUniform,
            //          0.2, 0.2, 0.2
            //      );

            //      gl.uniform3f(
            //          programShading.pointLightingLocationUniform, 
            //          -10.0, 4.0, -20.0
            //      );

            //      gl.uniform3f(
            //          programShading.pointLightingSpecularColorUniform,
            //          0.8, 0.8, 0.8
            //      );

            //      gl.uniform3f(
            //          programShading.pointLightingDiffuseColorUniform,
            //          0.8, 0.8, 0.8
            //      );
            //  }

            //  gl.uniform1i(programShading.useTexturesUniform, 1);

            //  gl.activeTexture(gl.TEXTURE0);
            //  gl.bindTexture(gl.TEXTURE_2D, checkerGrayTexture);
            //  gl.uniform1i(programShading.samplerUniform, 0);

            //  gl.uniform1f(programShading.materialShininessUniform, 32.0);

            //  gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexTextureCoordBuffer);
            //  gl.vertexAttribPointer(programShading.textureCoordAttribute, planeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //  gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
            //  gl.vertexAttribPointer(programShading.vertexNormalAttribute, planeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            // }
            if (programShading == shaderProgramDepth) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
            }
            if (programShading == shaderProgramFocalDepth) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
                
                gl.uniform3f(programShading.cameraFrontsUniform, myCamera.Front[0], myCamera.Front[1], myCamera.Front[2]);

                //console.log(myCamera.Position[0]);
                //console.log(myCamera.Position[1]);
                //console.log(myCamera.Position[2]);
                gl.uniform3f(programShading.cameraPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

                gl.uniform3f(programShading.focalPlanePosUniform, positionFocalPlane[0], positionFocalPlane[1], positionFocalPlane[2]);

                var aux = vec3.create();
                var _aux = vec3.create();
                vec3.add(_aux, positionFocalPlane, myCamera.Position);
                vec3.scaleAndAdd(aux, myCamera.Position, _aux, -1);
                var uFdist = Math.sqrt(vec3.squaredLength(aux));
                //console.log(uFdist);
                //console.log(positionFocalPlane);
                gl.uniform1f(programShading.focalDistanceUniform, uFocalDistance);

            }
            if (programShading == shaderProgramLightingPhong) {
                //console.log("PHONG SHADING");

                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
                gl.enableVertexAttribArray(programShading.textureCoordAttribute);

                gl.uniform3f(programShading.objectColorUniform, 1.0, 0.5, 0.31);
                gl.uniform3f(programShading.lightColorUniform, 1.0, 1.0, 1.0);
                gl.uniform3f(programShading.lightPosUniform, lightPos[0], lightPos[1], lightPos[1]);
                gl.uniform3f(programShading.viewPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

                gl.uniform1i(gl.getUniformLocation(programShading, "uUseTexture"), 1);
                gl.uniform1i(gl.getUniformLocation(programShading, "uDisableLighting"), 0);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, skyTexture);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.diffuse"), 0);
                gl.uniform1f(gl.getUniformLocation(programShading, "material.shininess"), 1.0);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.hasSpecular"), 0);

                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.direction"), -0.2, -1, -0.3);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.ambient"), 0.05, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.diffuse"), 0.8, 0.8, 0.8);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.specular"), 0.5, 0.5, 0.5);

                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].position"), lightPointPos[0], lightPointPos[1], lightPointPos[2]);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].ambient"), 0.05, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].diffuse"), 0.8, 0.8, 0.8);
                gl.uniform3f(gl.getUniformLocation(programShading, "pointLights[0].specular"), 1.0, 1.0, 1.0);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].constant"), 1.0);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].linear"), 0.09);
                gl.uniform1f(gl.getUniformLocation(programShading, "pointLights[0].quadratic"), 0.032);


                gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
                gl.vertexAttribPointer(programShading.vertexNormalAttribute, planeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexTextureCoordBuffer);
                gl.vertexAttribPointer(programShading.textureCoordAttribute, planeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }
            if (programShading == shaderProgramDepthObjectSpace) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
            }
            if (programShading == shaderProgramDepthPass) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.uniform1f(gl.getUniformLocation(programShading, "uFar"), myCamera.GetFarValue());
                gl.uniform1f(gl.getUniformLocation(programShading, "uNear"), myCamera.GetNearValue());
                //gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                //gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

            mat4.identity(mMatrix);
            var aux = mat4.create();
            mat4.identity(aux);

            mat4.identity(vMatrix);
            //mat4.translate(vMatrix, vMatrix, [0, 0, -300]);
            vMatrix = myCamera.GetViewMatrix();


            // FIRST MATRIX TRANSFORMS
            //mat4.translate(mvMatrix, [0.0, 0.0, -60]);
            //mat4.rotate(mvMatrix, degToRad(23.4), [1, 1, 1]);
            //mat4.rotate(mvMatrix, degToRad(teapotAngle), [0, 1, 0]);

            // SECOND MATRIX TRANSFORMS
            //mat4.scale(mvMatrix, [2.2, 2.2, 2.2]);
            mat4.translate(mMatrix, mMatrix, [0, 170, -1200]);
            //mat4.fromScaling(mvMatrix, [8.2, 8.2, 8.2]); 

            //mat4.translate(mvMatrix, aux, vec3.fromValues(0.5, 0.0, 0.0));
            //mat4.rotate(mMatrix, mMatrix, degToRad(23.4), [1, 0, 0]);
            mat4.rotate(mMatrix, mMatrix, degToRad(90), [1, 0, 0]);
            //mat4.multiplyScalar(mvMatrix, mvMatrix, [1.0, 1.0, 1.0]);
            mat4.fromScaling(aux, [2000.0, 2000.0, 2000.0]);
            mat4.multiply(mMatrix, mMatrix, aux);

            
            gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
            gl.vertexAttribPointer(programShading.vertexPositionAttribute, planeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeVertexIndexBuffer);
            setMatrixUniforms(programShading);
            gl.drawElements(gl.TRIANGLES, planeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }



        function drawSphere(programShading, translatePos, scaleVal, color) {
            gl.useProgram(programShading);

            pMatrix = myCamera.GetProjectionMatrix();

            // if (programShading == shaderProgram) {
            //     gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
            //     gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
            //     gl.enableVertexAttribArray(programShading.textureCoordAttribute);

            //     gl.uniform1i(programShading.showSpecularHighlightUnigorm, 1);
            //     var lighting = 1;
            //     gl.uniform1i(programShading.useLightingUniform, lighting);

            //     if (lighting) {
            //         gl.uniform3f(
            //             programShading.ambientColorUniform, 
            //             0.2, 0.2, 0.2
            //         );

            //         gl.uniform3f(
            //             programShading.pointLightingLocationUniform,
            //             -10.0, 4.0, -20.0  
            //         );

            //         gl.uniform3f(
            //             programShading.pointLightingSpecularColorUniform,
            //             0.8, 0.8, 0.8
            //         );

            //         gl.uniform3f(
            //             programShading.pointLightingDiffuseColorUniform,
            //             0.8, 0.8, 0.8
            //         );
            //     }

            //     gl.uniform1i(programShading.useTexturesUniform, 1);

            //     gl.activeTexture(gl.TEXTURE0);
            //     //gl.bindTexture(gl.TEXTURE_2D, sphereTexture);
            //     gl.uniform1i(programShading.samplerUniform, 0);

            //     gl.uniform1f(programShading.materialShininessUniform, 32.0);

            //     gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer);
            //     gl.vertexAttribPointer(programShading.textureCoordAttribute, sphereVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            //     gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            //     gl.vertexAttribPointer(programShading.vertexNormalAttribute, sphereVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
            // }
            if (programShading == shaderProgramDepth) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
            }
            if (programShading == shaderProgramFocalDepth) 
            {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());

                gl.uniform3f(programShading.cameraFrontsUniform, myCamera.Front[0], myCamera.Front[1], myCamera.Front[2]);

                gl.uniform3f(programShading.cameraPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

                gl.uniform3f(programShading.focalPlanePosUniform, positionFocalPlane[0], positionFocalPlane[1], positionFocalPlane[2]);

                var aux = vec3.create();
                var _aux = vec3.create();
                vec3.add(_aux, positionFocalPlane, myCamera.Position);
                vec3.scaleAndAdd(aux, myCamera.Position, _aux, -1);
                var uFdist = Math.sqrt(vec3.squaredLength(aux));

                gl.uniform1f(programShading.focalDistanceUniform, uFocalDistance);
            }
            if (programShading == shaderProgramLightingPhong) {
                //console.log("PHONG SHADING");

                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.enableVertexAttribArray(programShading.vertexNormalAttribute);
                gl.enableVertexAttribArray(programShading.textureCoordAttribute);

                gl.uniform3f(programShading.objectColorUniform, 1.0, 0.5, 0.31);
                gl.uniform3f(programShading.lightColorUniform, 1.0, 1.0, 1.0);
                gl.uniform3f(programShading.lightPosUniform, lightPos[0], lightPos[1], lightPos[1]);
                gl.uniform3f(programShading.viewPosUniform, myCamera.Position[0], myCamera.Position[1], myCamera.Position[2]);

                gl.uniform1i(gl.getUniformLocation(programShading, "uUseTexture"), 0);
                gl.uniform1i(gl.getUniformLocation(programShading, "uDisableLighting"), 1);

                gl.activeTexture(gl.TEXTURE0); 
                gl.bindTexture(gl.TEXTURE_2D, galvanizedTexture);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.diffuse"), 0);
                gl.uniform1f(gl.getUniformLocation(programShading, "material.shininess"), 128.0);
                gl.uniform1i(gl.getUniformLocation(programShading, "material.hasSpecular"), 1);

                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.direction"), -0.2, -1, -0.3);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.ambient"), 0.05, 0.05, 0.05);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.diffuse"), 0.8, 0.8, 0.8);
                gl.uniform3f(gl.getUniformLocation(programShading, "dirLight.specular"), 0.5, 0.5, 0.5);

                gl.uniform3f(gl.getUniformLocation(programShading, "staticColor"), color[0], color[1], color[2]);

                gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
                gl.vertexAttribPointer(programShading.vertexNormalAttribute, sphereVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer);
                gl.vertexAttribPointer(programShading.textureCoordAttribute, sphereVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
            }
            if (programShading == shaderProgramDepthObjectSpace) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
                gl.uniform1f(programShading.nearUniform, myCamera.GetNearValue());
                gl.uniform1f(programShading.farUniform, myCamera.GetFarValue());
            }
            if (programShading == shaderProgramHdrColor) {
                gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);

                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.uniform3f(gl.getUniformLocation(programShading, "color"), color[0], color[1], color[2]);
            }
            if (programShading == shaderProgramDepthPass) {
                gl.enableVertexAttribArray(programShading.vertexPositionAttribute);
                gl.uniform1f(gl.getUniformLocation(programShading, "uFar"), myCamera.GetFarValue());
                gl.uniform1f(gl.getUniformLocation(programShading, "uNear"), myCamera.GetNearValue());
                //gl.disableVertexAttribArray(shaderProgram.vertexNormalAttribute);
                //gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

            mat4.identity(mMatrix);
            var aux = mat4.create();
            mat4.identity(aux);

            mat4.identity(vMatrix);
            vMatrix = myCamera.GetViewMatrix();

            mat4.translate(mMatrix, mMatrix, [translatePos[0], translatePos[1], translatePos[2]]);
            mat4.fromScaling(aux, [scaleVal[0], scaleVal[1], scaleVal[2]]);
            mat4.multiply(mMatrix, mMatrix, aux);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(programShading.vertexPositionAttribute, sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            setMatrixUniforms(programShading);
            gl.drawElements(gl.TRIANGLES, sphereVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

		function drawScene(programToDraw) {
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			drawPlaneHorizon(programToDraw);
            drawPlane(programToDraw);

			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, 400.0));
			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, 100.0));
			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, 0.0));
			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, -60));
			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, -150));
			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, -300));
			drawTeapot(programToDraw, vec3.fromValues(0, 8.0, -800));

            drawSphere(programToDraw, vec3.fromValues(lightPointPos[0], lightPointPos[1], lightPointPos[2]), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(100 * 181/255, 20 * 134/255, 20 * 144/255));

            drawSphere(programToDraw, vec3.fromValues(0,55,0), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(181/255, 20 * 134/255, 80 * 144/255));
            drawSphere(programToDraw, vec3.fromValues(0,40,-20), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 214/255, 10 * 211/255, 10 * 218/255));
            drawSphere(programToDraw, vec3.fromValues(20,30,-40), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 242/255, 10 * 240/255, 10 * 241/255));
            drawSphere(programToDraw, vec3.fromValues(-30,20,-60), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 57/255, 10 * 93/255, 10 * 109/255));
            drawSphere(programToDraw, vec3.fromValues(-50,40,-120), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 62/255, 10 * 101/255, 10 * 54/255));
            drawSphere(programToDraw, vec3.fromValues(-80,25,-200), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 197/255, 10 * 197/255, 10 * 197/255));

            drawSphere(programToDraw, vec3.fromValues(20,55,-50), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 142/255, 10 * 90/255, 10 * 92/255));
            drawSphere(programToDraw, vec3.fromValues(-10,40,-90), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 83/255, 10 * 79/255, 10 * 114/255));
            drawSphere(programToDraw, vec3.fromValues(50,30,-100), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(-60,20,-105), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(-50,40,-120), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(-35,25,-200), vec3.fromValues(2.0, 2.0, 2.0), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
			
		}

        function drawHDRBokehScene2D(programToDraw) {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            //drawPlane();
            drawSphere(programToDraw, vec3.fromValues(-4.3812, 1.7, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(181/255, 20 * 134/255, 80 * 144/255));
            drawSphere(programToDraw, vec3.fromValues(-2.8, 3.0, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 214/255, 10 * 211/255, 10 * 218/255));
            drawSphere(programToDraw, vec3.fromValues(-2.2, 2.2, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 242/255, 10 * 240/255, 10 * 241/255));
            drawSphere(programToDraw, vec3.fromValues(0.1531, -0.2861, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 57/255, 10 * 93/255, 10 * 109/255));
            drawSphere(programToDraw, vec3.fromValues(0.0, -0.70, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 62/255, 10 * 101/255, 10 * 54/255));
            drawSphere(programToDraw, vec3.fromValues(-2.18, -1.90, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 197/255, 10 * 197/255, 10 * 197/255));
            drawSphere(programToDraw, vec3.fromValues(-0.0094, -2.92, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 142/255, 10 * 90/255, 10 * 92/255));
            drawSphere(programToDraw, vec3.fromValues(0.42, -2.89, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 83/255, 10 * 79/255, 10 * 114/255));
            drawSphere(programToDraw, vec3.fromValues(0.37, -2.0, 0.0), vec3.fromValues(0.2, 0.2, 0.2), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));

            drawSphere(programToDraw, vec3.fromValues(0.22, 0.28, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.27, 0.36, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.29, 0.20, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.33, 0.29, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.33, 0.45, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.40, 0.43, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.3813, 0.59, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 * 86/255, 10 * 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.40, 0.76, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(10 * 132/255, 10 *86/255, 10 * 133/255));


            drawSphere(programToDraw, vec3.fromValues(0.38, 0.17, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.42, 0.25, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.50, 0.42, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.52, 0.18, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.55, 0.29, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.57, 0.17, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.61, 0.22, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));

            drawSphere(programToDraw, vec3.fromValues(0.66, 0.0, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.68, 0.1850, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.72, 0.21, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.73, 0.055, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.77, 0.1611, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.7953, 0.0, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            drawSphere(programToDraw, vec3.fromValues(0.84, 0.083, 0.0), vec3.fromValues(0.1, 0.1, 0.1), vec3.fromValues(132/255, 86/255, 133/255));
            
        }


		function drawScreenFillingTextureBokeh() {
			gl.useProgram(shaderProgramBufferImage);

			shaderProgramBufferImage.vertexPositionAttribute = gl.getAttribLocation(shaderProgramBufferImage, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgramBufferImage.vertexPositionAttribute);

			shaderProgramBufferImage.textureCoordAttribute = gl.getAttribLocation(shaderProgramBufferImage, "aTextureCoord");
			gl.enableVertexAttribArray(shaderProgramBufferImage.textureCoordAttribute);

			shaderProgramBufferImage.samplerChannel0Uniform = gl.getUniformLocation(shaderProgramBufferImage, "iChannel0");
			shaderProgramBufferImage.samplerChannel1Uniform = gl.getUniformLocation(shaderProgramBufferImage, "iChannel1");
			shaderProgramBufferImage.samplerChannel2Uniform = gl.getUniformLocation(shaderProgramBufferImage, "iChannel2");
			shaderProgramBufferImage.samplerChannel3Uniform = gl.getUniformLocation(shaderProgramBufferImage, "iChannel3");

			shaderProgramBufferImage.samplerFocalDepthUniform = gl.getUniformLocation(shaderProgramBufferImage, "uSamplerFocalDepth");

			shaderProgramBufferImage.resolutionUniform = gl.getUniformLocation(shaderProgramBufferImage, "iResolution");
			shaderProgramBufferImage.timeUniform = gl.getUniformLocation(shaderProgramBufferImage, "iTime");

            shaderProgramBufferImage.bokehStrengthUniform = gl.getUniformLocation(shaderProgramBufferImage, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


			gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgramBufferImage.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
			gl.vertexAttribPointer(shaderProgramBufferImage.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferABokeh);
			gl.uniform1i(shaderProgramBufferImage.samplerChannel0Uniform, 0);

			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferBBokeh);
			gl.uniform1i(shaderProgramBufferImage.samplerChannel1Uniform, 1);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferCBokeh);
			gl.uniform1i(shaderProgramBufferImage.samplerChannel2Uniform, 2);

			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferDBokeh);
			gl.uniform1i(shaderProgramBufferImage.samplerChannel3Uniform, 3);

			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, textureFramebufferFocalDepthScene);
			gl.uniform1i(shaderProgramBufferImage.samplerFocalDepthUniform, 4);

			gl.uniform3f(shaderProgramBufferImage.resolutionUniform, gl.viewportWidth, gl.viewportHeight, 1.0);
			gl.uniform1f(shaderProgramBufferImage.timeUniform, elapsed);

            gl.uniform1f(shaderProgramBufferImage.bokehStrengthUniform, bokehStrength);

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
			gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		}

        function drawScreenTexture(textureToDraw, enableBorder, drawCoC, normColor, multiplyColor) {
            gl.useProgram(shaderProgramBufferRendToText);

            shaderProgramBufferRendToText.vertexPositionAttribute = gl.getAttribLocation(shaderProgramBufferRendToText, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramBufferRendToText.vertexPositionAttribute);

            shaderProgramBufferRendToText.textureCoordAttribute = gl.getAttribLocation(shaderProgramBufferRendToText, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramBufferRendToText.textureCoordAttribute);

            shaderProgramBufferRendToText.samplerUniform = gl.getUniformLocation(shaderProgramBufferRendToText, "uSampler");

            shaderProgramBufferRendToText.modelMatrixUniform = gl.getUniformLocation(shaderProgramBufferRendToText, "model");

            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
            gl.disable(gl.DEPTH_TEST);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramBufferRendToText.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramBufferRendToText.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureToDraw);
            gl.uniform1i(shaderProgramBufferRendToText.samplerUniform, 0);

            gl.uniform1f(gl.getUniformLocation(shaderProgramBufferRendToText, "drawCoC"), drawCoC);
            gl.uniform1f(gl.getUniformLocation(shaderProgramBufferRendToText, "normColor"), normColor);
            gl.uniform1f(gl.getUniformLocation(shaderProgramBufferRendToText, "multiplyColor"), multiplyColor);


            mat4.identity(mMatrix);
            var aux = mat4.create();

            mat4.fromScaling(aux, [1.0, 1.0, 1.0]);
            mat4.multiply(mMatrix, mMatrix, aux);

            gl.uniformMatrix4fv(shaderProgramBufferRendToText.modelMatrixUniform, false, mMatrix);

            if (enableBorder == 0) {
                gl.uniform1i(gl.getUniformLocation(shaderProgramBufferRendToText, "uDrawBorder"), 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
                gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            } else {
                gl.uniform1i(gl.getUniformLocation(shaderProgramBufferRendToText, "uDrawBorder"), 1);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
                gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                mat4.fromScaling(aux, [0.97, 0.97, 1.0]);
                mat4.multiply(mMatrix, mMatrix, aux);

                gl.uniformMatrix4fv(shaderProgramBufferRendToText.modelMatrixUniform, false, mMatrix);

                gl.uniform1i(gl.getUniformLocation(shaderProgramBufferRendToText, "uDrawBorder"), 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
                gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            }

            gl.enable(gl.DEPTH_TEST);
        }


		var lastTime = 0;

		function animate() {
			var timeNow = new Date().getTime();
			if (lastTime != 0) {
				var elapsed = timeNow - lastTime;

				teapotAngle += 0.05 * elapsed;
			}
			lastTime = timeNow;
		}

		function calculateDeltaTime() {
			var currentFrame = new Date().getTime();
			//deltaTime = (currentFrame - lastFrame)/10000;
			//deltaTime = (currentFrame - lastFrame)/1000;
			deltaTime = (currentFrame - lastFrame)/100;
			//deltaTime = (currentFrame - lastFrame)/10;
			//deltaTime = (currentFrame - lastFrame)/1;
			lastFrame = currentFrame;
		}

		function debugCamera() {
			console.log("CAMERA POSITION: "+myCamera.Position);
            console.log("CAMERA PITCH: "+myCamera.Pitch);
            console.log("CAMERA YAW: "+myCamera.Yaw);
		}

		function setupFocalPlane() {
			//console.log("myCamera.Position: "+ myCamera.Position);
			//console.log("myCamera.Front: "+ myCamera.Front);
			var aux = vec3.create();
			if (myCamera.Front[2] > 0) {
				vec3.scale(aux, myCamera.Front, -distanceFocalPlane);	
			} else  if (myCamera.Front[2] <= 0) {
				vec3.scale(aux, myCamera.Front, distanceFocalPlane);	
			}
			var _aux = vec3.create();
			vec3.add(_aux, myCamera.Position, aux);
			//console.log("positionFocalPlane: " + _aux);
			//console.log("LENGTH OF DIR VECTOR: "+ (Math.sqrt(vec3.sqrLen(myCamera.Front))));
			positionFocalPlane = _aux;

			//console.log("DIFFERENCE: "+ Math.sqrt(vec3.squaredDistance(positionFocalPlane, myCamera.Position)));
		}

		function clock() 
		{
			var timeNow = new Date().getTime();
			if (time_start != 0)
			{
				elapsed = timeNow - time_start;
				elapsed /= 1000;
			}
		}

        function debugGaussian(samplePoint) {
            var weight = 0;
            var acum = 0;
            for (var i = 0; i < 16; i++) {
                weight = (1.0 / Math.sqrt(2.0 * Math.PI)) * Math.exp(-1 * Math.pow(i, 2)/2.0);    
                acum += weight;
            }
            //console.log(weight);
        }

        function split(array, first, last) {
            // pivot value
            var pivot = array[first];

            // aux var
            var tmp;

            var left = first + 1;
            var right = last;

            do {    // Pivoting
                while ((left <= right) && (array[left] <= pivot)) {
                    left++;
                }
                while ((left <= right) && (array[right] > pivot)) {
                    right--;
                }
                if (left < right) {
                    tmp = array[left];
                    array[left] = array[right];
                    array[right] = tmp;
                    right--;
                    left++;
                }
            } while (left <= right);

            // Place the pivot on his spot
            tmp = array[first];
            array[first] = array[right];
            array[right] = tmp;

            // Position of pivot
            return right;
        }

        function quicksort (array, left, right) 
        {
            var pivot; // Pivot position

            if (left < right) {
                pivot = split(array, left, right);
                quicksort(array, left, pivot - 1);
                quicksort(array, pivot + 1, right);
            }

            return array;
        }

        // variables:
        //  input -- the array of items to be sorted
        //  key(x) -- function that returns the key for item x
        //  k -- a number such that all keys are in the range 0..k-1
        //  count -- an array of numbers, with indexes 0..k-1, initially all zero
        //  output -- an array of items, with indexes 0..n-1
        //  x -- an individual input item, used within the algorithm
        //  total, oldCount i -- numbers used within the algorithm
        function countsort(input, k) {
            var _count = [];
            var output = [];
            var oldCount;
            var total;

            _count = Array.apply(null, Array(k)).map(Number.prototype.valueOf, 0);
            // calculate the histogram of key frequencies:
            for (var x = 0; x < k; x++) 
                _count[input[x]] += 1;

            // calculate the starting index for each key:
            var total = 0;
            for (var i = 0; i < k; i++) { // i - 0, 1, ... k - 1
                oldCount = _count[i];
                _count[i] = total;
                total += oldCount;
            }

            // copy to output array, preserving order of inputs with equal keys
            for (var x = 0; x < k; x++) {
                output[_count[input[x]]] = x;
                _count[input[x]] += 1;
            }

            return output;
        }

        function interchangesort(array) {
            // We use an anidated loop
            for (var i = 0; i < array.length-1; i++) {
                for (var j =i+1; j < array.length; j++) {
                    if (array[i] > array[j]) {
                        // Interchange of values
                        var auxvar = array[i];
                        array[i] = array[j];
                        array[j] = auxvar;
                    }
                }
            }
            return array;
        }

        function debugSorting() {
            var a = [0, 1, 3, 2, 5, 3, 7, 6, 9, 11, 10, 1];
            //a = quicksort(a, 0, a.length-1);
            //a = countsort(a, a.length);
            a = interchangesort(a);
        }

        function clock() 
        {
            var timeNow = new Date().getTime();
            if (time_start != 0)
            {
                elapsed = timeNow - time_start;
                elapsed /= 1000;
            }
        }

		function tick() {
			//gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			//gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

			requestAnimFrame(tick);
			handleKeys();
			//setupFocalPlane();
			//debugCamera();
			//drawScene(shaderProgramFocalDepth);
			//drawSceneDepth();
			//drawSceneFocalDepth();
			
			//drawEffects();
            drawBokehEffects();

			animate();
			calculateDeltaTime();
            debugGaussian();
			clock();

            handleStatistics();

			//console.log(positionFocalPlane);
		}

		 function drawBufferABokeh() {
            gl.useProgram(shaderProgramBufferA); 

            shaderProgramBufferA.vertexPositionAttribute = gl.getAttribLocation(shaderProgramBufferA, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramBufferA.vertexPositionAttribute);

            shaderProgramBufferA.textureCoordAttribute = gl.getAttribLocation(shaderProgramBufferA, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramBufferA.textureCoordAttribute);

            shaderProgramBufferA.samplerUniform = gl.getUniformLocation(shaderProgramBufferA, "uSampler");

            shaderProgramBufferA.samplerFocalDepthUniform = gl.getUniformLocation(shaderProgramBufferA, "uSamplerFocalDepth");

            shaderProgramBufferA.resolutionUniform = gl.getUniformLocation(shaderProgramBufferA, "iResolution");

            shaderProgramBufferA.timeUniform = gl.getUniformLocation(shaderProgramBufferA, "iTime");

            shaderProgramBufferA.bokehStrengthUniform = gl.getUniformLocation(shaderProgramBufferA, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramBufferA.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramBufferA.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramBufferA.samplerUniform, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferFocalDepthScene);
            gl.uniform1i(shaderProgramBufferA.samplerFocalDepthUniform, 1);

            gl.uniform3f(shaderProgramBufferA.resolutionUniform, gl.viewportWidth, gl.viewportHeight, 1.0);
            gl.uniform1f(shaderProgramBufferA.timeUniform, elapsed);

            gl.uniform1f(shaderProgramBufferA.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }


        function drawBufferBBokeh() {
            gl.useProgram(shaderProgramBufferB); 

            shaderProgramBufferB.vertexPositionAttribute = gl.getAttribLocation(shaderProgramBufferB, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramBufferB.vertexPositionAttribute);

            shaderProgramBufferB.textureCoordAttribute = gl.getAttribLocation(shaderProgramBufferB, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramBufferB.textureCoordAttribute);

            shaderProgramBufferB.samplerUniform = gl.getUniformLocation(shaderProgramBufferB, "uSampler");

            shaderProgramBufferB.samplerFocalDepthUniform = gl.getUniformLocation(shaderProgramBufferB, "uSamplerFocalDepth");

            shaderProgramBufferB.resolutionUniform = gl.getUniformLocation(shaderProgramBufferB, "iResolution");

            shaderProgramBufferB.timeUniform = gl.getUniformLocation(shaderProgramBufferB, "iTime");

            shaderProgramBufferB.bokehStrengthUniform = gl.getUniformLocation(shaderProgramBufferB, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramBufferB.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramBufferB.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramBufferB.samplerUniform, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferFocalDepthScene);
            gl.uniform1i(shaderProgramBufferB.samplerFocalDepthUniform, 1);

            gl.uniform3f(shaderProgramBufferB.resolutionUniform, gl.viewportWidth, gl.viewportHeight, 1.0);
            gl.uniform1f(shaderProgramBufferB.timeUniform, elapsed);

            gl.uniform1f(shaderProgramBufferB.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawBufferCBokeh() {
            gl.useProgram(shaderProgramBufferC); 

            shaderProgramBufferC.vertexPositionAttribute = gl.getAttribLocation(shaderProgramBufferC, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramBufferC.vertexPositionAttribute);

            shaderProgramBufferC.textureCoordAttribute = gl.getAttribLocation(shaderProgramBufferC, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramBufferC.textureCoordAttribute);

            shaderProgramBufferC.samplerUniform = gl.getUniformLocation(shaderProgramBufferC, "iChannel0");

            shaderProgramBufferC.samplerFocalDepthUniform = gl.getUniformLocation(shaderProgramBufferC, "uSamplerFocalDepth");

            shaderProgramBufferC.resolutionUniform = gl.getUniformLocation(shaderProgramBufferC, "iResolution");

            shaderProgramBufferC.timeUniform = gl.getUniformLocation(shaderProgramBufferC, "iTime");

            shaderProgramBufferC.bokehStrengthUniform = gl.getUniformLocation(shaderProgramBufferC, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramBufferC.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramBufferC.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferABokeh);
            gl.uniform1i(shaderProgramBufferC.samplerUniform, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferFocalDepthScene);
            gl.uniform1i(shaderProgramBufferC.samplerFocalDepthUniform, 1);

            gl.uniform3f(shaderProgramBufferC.resolutionUniform, gl.viewportWidth, gl.viewportHeight, 1.0);
            gl.uniform1f(shaderProgramBufferC.timeUniform, elapsed);

            gl.uniform1f(shaderProgramBufferC.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawBufferDBokeh() {
            gl.useProgram(shaderProgramBufferD); 

            shaderProgramBufferD.vertexPositionAttribute = gl.getAttribLocation(shaderProgramBufferD, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramBufferD.vertexPositionAttribute);

            shaderProgramBufferD.textureCoordAttribute = gl.getAttribLocation(shaderProgramBufferD, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramBufferD.textureCoordAttribute);

            shaderProgramBufferD.samplerUniform = gl.getUniformLocation(shaderProgramBufferD, "iChannel0");

            shaderProgramBufferD.samplerFocalDepthUniform = gl.getUniformLocation(shaderProgramBufferD, "uSamplerFocalDepth");

            shaderProgramBufferD.resolutionUniform = gl.getUniformLocation(shaderProgramBufferD, "iResolution");

            shaderProgramBufferD.timeUniform = gl.getUniformLocation(shaderProgramBufferD, "iTime");

            shaderProgramBufferD.bokehStrengthUniform = gl.getUniformLocation(shaderProgramBufferD, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramBufferD.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramBufferD.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferABokeh);
            gl.uniform1i(shaderProgramBufferD.samplerUniform, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferFocalDepthScene);
            gl.uniform1i(shaderProgramBufferD.samplerFocalDepthUniform, 1);

            gl.uniform3f(shaderProgramBufferD.resolutionUniform, gl.viewportWidth, gl.viewportHeight, 1.0);
            gl.uniform1f(shaderProgramBufferD.timeUniform, elapsed);

            gl.uniform1f(shaderProgramBufferD.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawBokehFirstPassVertical() {
            gl.useProgram(shaderProgramFirstPassOpticalBokeh);

            shaderProgramFirstPassOpticalBokeh.vertexPositionAttribute = gl.getAttribLocation(shaderProgramFirstPassOpticalBokeh, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramFirstPassOpticalBokeh.vertexPositionAttribute);

            shaderProgramFirstPassOpticalBokeh.textureCoordAttribute = gl.getAttribLocation(shaderProgramFirstPassOpticalBokeh, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramFirstPassOpticalBokeh.textureCoordAttribute);

            shaderProgramFirstPassOpticalBokeh.samplerUniform = gl.getUniformLocation(shaderProgramFirstPassOpticalBokeh, "uSampler");

            shaderProgramFirstPassOpticalBokeh.resolutionUniform = gl.getUniformLocation(shaderProgramFirstPassOpticalBokeh, "uResolution");

            shaderProgramFirstPassOpticalBokeh.bokehStrengthUniform = gl.getUniformLocation(shaderProgramFirstPassOpticalBokeh, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassOpticalBokeh.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassOpticalBokeh.textureCoordAttribute,
                screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramFirstPassOpticalBokeh.samplerUniform, 0);

            gl.uniform2f(shaderProgramFirstPassOpticalBokeh.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramFirstPassOpticalBokeh.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawBokehFirstPassDiagonalDown() {
            gl.useProgram(shaderProgramFirstPassOpBokDiag);

            shaderProgramFirstPassOpBokDiag.vertexPosition = gl.getAttribLocation(shaderProgramFirstPassOpBokDiag, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramFirstPassOpBokDiag.vertexPositionAttribute);

            shaderProgramFirstPassOpBokDiag.textureCoordAttribute = gl.getAttribLocation(
                shaderProgramFirstPassOpBokDiag, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramFirstPassOpBokDiag.textureCoordAttribute);

            shaderProgramFirstPassOpBokDiag.samplerUniform = gl.getUniformLocation(
                shaderProgramFirstPassOpBokDiag, "uSampler");

            shaderProgramFirstPassOpBokDiag.resolutionUniform = gl.getUniformLocation(
                shaderProgramFirstPassOpBokDiag, "uResolution");

            shaderProgramFirstPassOpBokDiag.bokehStrengthUniform = gl.getUniformLocation(
                shaderProgramFirstPassOpBokDiag, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassOpBokDiag.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassOpBokDiag.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramFirstPassOpBokDiag.samplerUniform, 0);

            gl.uniform2f(shaderProgramFirstPassOpBokDiag.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramFirstPassOpBokDiag.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawBokehFirstPassCombined() {
            //shaderProgramFirstPassCombined
            gl.useProgram(shaderProgramFirstPassCombined);

            shaderProgramFirstPassCombined.vertexPositionAttribute = gl.getAttribLocation(shaderProgramFirstPassCombined, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramFirstPassCombined.vertexPositionAttribute);

            shaderProgramFirstPassCombined.textureCoordAttribute = gl.getAttribLocation(shaderProgramFirstPassCombined, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramFirstPassCombined.textureCoordAttribute);

            shaderProgramFirstPassCombined.samplerUniform = gl.getUniformLocation(shaderProgramFirstPassCombined, "uSampler");

            shaderProgramFirstPassCombined.resolutionUniform = gl.getUniformLocation(shaderProgramFirstPassCombined, "uResolution");

            shaderProgramFirstPassCombined.bokehStrengthUniform = gl.getUniformLocation(shaderProgramFirstPassCombined, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassCombined.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassCombined.textureCoordAttribute,
                screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramFirstPassCombined.samplerUniform, 0);

            gl.uniform2f(shaderProgramFirstPassCombined.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramFirstPassCombined.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);


        }

        function drawBokehSecondPassDiagonalLeft() {
            gl.useProgram(shaderProgramSecondPassOpBokDiagLeft);

            shaderProgramSecondPassOpBokDiagLeft.vertexPosition = gl.getAttribLocation(shaderProgramSecondPassOpBokDiagLeft, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramSecondPassOpBokDiagLeft.vertexPositionAttribute);

            shaderProgramSecondPassOpBokDiagLeft.textureCoordAttribute = gl.getAttribLocation(shaderProgramSecondPassOpBokDiagLeft, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramSecondPassOpBokDiagLeft.textureCoordAttribute);

            shaderProgramSecondPassOpBokDiagLeft.samplerUniform = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagLeft, "uSampler");

            shaderProgramSecondPassOpBokDiagLeft.resolutionUniform = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagLeft, "uResolution");

            shaderProgramSecondPassOpBokDiagLeft.bokehStrengthUniform = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagLeft, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramSecondPassOpBokDiagLeft.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramSecondPassOpBokDiagLeft.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureAuxFramebuffer);
            gl.uniform1i(shaderProgramSecondPassOpBokDiagLeft.samplerUniform, 0);

            gl.uniform2f(shaderProgramSecondPassOpBokDiagLeft.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramSecondPassOpBokDiagLeft.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawBokehSecondPassDiagonalRight() {
            gl.useProgram(shaderProgramSecondPassOpBokDiagRight);

            shaderProgramSecondPassOpBokDiagRight.vertexPosition = gl.getAttribLocation(shaderProgramSecondPassOpBokDiagRight, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramSecondPassOpBokDiagRight.vertexPositionAttribute);

            shaderProgramSecondPassOpBokDiagRight.textureCoordAttribute = gl.getAttribLocation(shaderProgramSecondPassOpBokDiagRight, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramSecondPassOpBokDiagRight.textureCoordAttribute);

            shaderProgramSecondPassOpBokDiagRight.samplerUniform = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagRight, "uSampler");

            //shaderProgramSecondPassOpBokDiagRight.samplerUniform2 = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagRight, "uSampler2");


            shaderProgramSecondPassOpBokDiagRight.resolutionUniform = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagRight, "uResolution");

            shaderProgramSecondPassOpBokDiagRight.bokehStrengthUniform = gl.getUniformLocation(shaderProgramSecondPassOpBokDiagRight, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramSecondPassOpBokDiagRight.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramSecondPassOpBokDiagRight.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferDBokeh);
            gl.uniform1i(shaderProgramSecondPassOpBokDiagRight.samplerUniform, 0);

            //gl.activeTexture(gl.TEXTURE1);
            //gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferBBokeh);
            //gl.uniform1i(shaderProgramSecondPassOpBokDiagRight.samplerUniform2, 1);

            gl.uniform2f(shaderProgramSecondPassOpBokDiagRight.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramSecondPassOpBokDiagRight.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        // shaderProgramBothPassesCombined
        function drawBokehPassesCombined() {
            gl.useProgram(shaderProgramBothPassesCombined);

            shaderProgramBothPassesCombined.vertexPosition = gl.getAttribLocation(shaderProgramBothPassesCombined, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramBothPassesCombined.vertexPositionAttribute);

            shaderProgramBothPassesCombined.textureCoordAttribute = gl.getAttribLocation(shaderProgramBothPassesCombined, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramBothPassesCombined.textureCoordAttribute);

            shaderProgramBothPassesCombined.samplerUniform = gl.getUniformLocation(shaderProgramBothPassesCombined, "uSampler");

            shaderProgramBothPassesCombined.samplerUniform2 = gl.getUniformLocation(shaderProgramBothPassesCombined, "uSampler2");


            shaderProgramBothPassesCombined.resolutionUniform = gl.getUniformLocation(shaderProgramBothPassesCombined, "uResolution");

            shaderProgramBothPassesCombined.bokehStrengthUniform = gl.getUniformLocation(shaderProgramBothPassesCombined, "bokehStrength");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramBothPassesCombined.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramBothPassesCombined.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferDBokeh);
            gl.uniform1i(shaderProgramBothPassesCombined.samplerUniform, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferBufferBBokeh);
            gl.uniform1i(shaderProgramBothPassesCombined.samplerUniform2, 1);

            gl.uniform2f(shaderProgramBothPassesCombined.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramBothPassesCombined.bokehStrengthUniform, bokehStrength);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }


        function setupBokehMode(mode) {
            gl.useProgram(shaderProgramBufferA);
            gl.uniform1i(gl.getUniformLocation(shaderProgramBufferA, "uEnableDepthBokeh"), mode);
            gl.useProgram(shaderProgramBufferB);
            gl.uniform1i(gl.getUniformLocation(shaderProgramBufferB, "uEnableDepthBokeh"), mode);
            gl.useProgram(shaderProgramBufferC);
            gl.uniform1i(gl.getUniformLocation(shaderProgramBufferC, "uEnableDepthBokeh"), mode);
            gl.useProgram(shaderProgramBufferD);
            gl.uniform1i(gl.getUniformLocation(shaderProgramBufferD, "uEnableDepthBokeh"), mode);
            gl.useProgram(shaderProgramBufferImage);
            gl.uniform1i(gl.getUniformLocation(shaderProgramBufferImage, "uEnableDepthBokeh"), mode);
        }

		function drawEffects() {
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferSetupSceneRGBA32F);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

			//drawScreenTexture(bokeh2DTexture, 0);
            drawHDRBokehScene2D(shaderProgramLightingPhong);

			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferFocalDepthScene);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

			drawScene(shaderProgramFocalDepth);

            gl.bindFramebuffer(gl.FRAMEBUFFER, auxFramebufferRGBA32F);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            //drawScene(shaderProgramDepthObjectSpace);
            drawBokehFirstPassVertical();

            
            var enableDepthBokeh = 0;
            setupBokehMode(enableDepthBokeh);

			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferABokehRGBA32F);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			//drawBufferABokeh();
            drawBokehSecondPassDiagonalLeft();


			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferBBokehRGBA32F);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			//drawBufferBBokeh();
            drawBokehSecondPassDiagonalRight();

			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferCBokehRGBA32F);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			//drawBufferCBokeh();
            drawBokehSecondPassDiagonalRight();

			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferDBokehRGBA32F);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			//drawBokehSecondPassDiagonalLeft();
            drawBokehFirstPassCombined();
            



			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

			//drawScreenFillingTextureBokeh();
            //drawScreenTexture(textureAuxFramebuffer, 0); // BUENA
            //drawScreenTexture(textureFramebufferSetupScene, 0);
            drawBokehPassesCombined();



            //gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            //gl.viewport(3 * (gl.viewportWidth/4), 3*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);            
            //drawScreenTexture(textureFramebufferFocalDepthScene);


            //gl.viewport(0 * (gl.viewportWidth/4), 3*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferABokeh);
            //gl.viewport(0 * (gl.viewportWidth/4), 2*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferBBokeh);
            //gl.viewport(0 * (gl.viewportWidth/4), 1*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferCBokeh);
            //gl.viewport(0 * (gl.viewportWidth/4), 0*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferDBokeh);


            gl.viewport(3 * (gl.viewportWidth/4), 3*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            drawScreenTexture(textureAuxFramebuffer, 1);

            gl.viewport(3 * (gl.viewportWidth/4), 2*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            drawScreenTexture(textureFramebufferBufferABokeh, 1);

            gl.viewport(3 * (gl.viewportWidth/4), 1*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            drawScreenTexture(textureFramebufferBufferBBokeh, 1);

            gl.viewport(3 * (gl.viewportWidth/4), 0*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            drawScreenTexture(textureFramebufferBufferDBokeh, 1);





            //gl.viewport(0 * (gl.viewportWidth/4), 3*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferABokeh);
            //gl.viewport(0 * (gl.viewportWidth/4), 2*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferBBokeh);
            //gl.viewport(0 * (gl.viewportWidth/4), 1*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferCBokeh);
            //gl.viewport(0 * (gl.viewportWidth/4), 0*(gl.viewportHeight/4.0), gl.viewportWidth/4.0, gl.viewportHeight/4.0);
            //drawScreenTexture(textureFramebufferBufferDBokeh);

		}

        function drawFirstPassBokeh(drawInputCoC) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(shaderProgramFirstPassBlur);

            shaderProgramFirstPassBlur.vertexPositionAttribute = gl.getAttribLocation(shaderProgramFirstPassBlur, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramFirstPassBlur.vertexPositionAttribute);

            shaderProgramFirstPassBlur.textureCoordAttribute = gl.getAttribLocation(
                shaderProgramFirstPassBlur, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramFirstPassBlur.textureCoordAttribute);

            shaderProgramFirstPassBlur.samplerUniform = gl.getUniformLocation(shaderProgramFirstPassBlur, "uSampler");

            shaderProgramFirstPassBlur.resolutionUniform = gl.getUniformLocation(shaderProgramFirstPassBlur, "uResolution");

            shaderProgramFirstPassBlur.bokehStrengthUniform = gl.getUniformLocation(shaderProgramFirstPassBlur, "bokehStrength");

            shaderProgramFirstPassBlur.timeUnifom = gl.getUniformLocation(shaderProgramFirstPassBlur, "uTime");

            shaderProgramFirstPassBlur.farBlurdistancelimitUniform = gl.getUniformLocation(shaderProgramFirstPassBlur, "farBlurdistancelimit");

            //shaderProgramFirstPassBlur.drawInputCoC = gl.getUniformLocation(shaderProgramFirstPassBlur, "drawInputCoC");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassBlur.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramFirstPassBlur.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferCoCSize);
            gl.uniform1i(shaderProgramFirstPassBlur.samplerUniform, 0);

            gl.uniform2f(shaderProgramFirstPassBlur.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramFirstPassBlur.bokehStrengthUniform, bokehStrength);

            gl.uniform1f(shaderProgramFirstPassBlur.timeUniform, elapsed);

            gl.uniform1f(shaderProgramFirstPassBlur.farBlurdistancelimitUniform, farBlurdistancelimit);

            //gl.uniform1f(shaderProgramFirstPassBlur.drawInputCoC, drawInputCoC);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawSecondPassBokeh(drawFirstBlur, drawFirstBlurCoC, drawSecondBlur, drawSecondBlurCoC, multiplyColor) {
            gl.useProgram(shaderProgramSecondPassBlur);


            shaderProgramSecondPassBlur.vertexPositionAttribute = gl.getAttribLocation(shaderProgramSecondPassBlur, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramSecondPassBlur.vertexPositionAttribute);

            shaderProgramSecondPassBlur.textureCoordAttribute = gl.getAttribLocation(shaderProgramSecondPassBlur, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramSecondPassBlur.textureCoordAttribute);

    
            shaderProgramSecondPassBlur.samplerUniform0 = gl.getUniformLocation(shaderProgramSecondPassBlur, "BlurPass1_0");
            shaderProgramSecondPassBlur.samplerUniform1 = gl.getUniformLocation(shaderProgramSecondPassBlur, "BlurPass1_1");


            shaderProgramSecondPassBlur.resolutionUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "uResolution");

            shaderProgramSecondPassBlur.bokehStrengthUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "bokehStrength");

            shaderProgramSecondPassBlur.timeUnifom = gl.getUniformLocation(shaderProgramFirstPassBlur, "uTime");

            shaderProgramSecondPassBlur.farBlurdistancelimitUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "farBlurdistancelimit");


            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramSecondPassBlur.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramSecondPassBlur.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, MRTfbData.t[0]);
            gl.uniform1i(shaderProgramSecondPassBlur.samplerUniform0, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, MRTfbData.t[1]);
            gl.uniform1i(shaderProgramSecondPassBlur.samplerUniform1, 1);

            gl.uniform2f(shaderProgramSecondPassBlur.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramSecondPassBlur.bokehStrengthUniform, bokehStrength);

            gl.uniform1f(shaderProgramSecondPassBlur.timeUniform, elapsed);

            shaderProgramSecondPassBlur.drawFirstBlurUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "drawFirstBlur");
            shaderProgramSecondPassBlur.drawFirstBlurCoCUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "drawFirstBlurCoC");
            shaderProgramSecondPassBlur.drawSecondBlurUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "drawSecondBlur");
            shaderProgramSecondPassBlur.drawSecondBlurCoCUniform = gl.getUniformLocation(shaderProgramSecondPassBlur, "drawSecondBlurCoC");

            shaderProgramSecondPassBlur.multiplyColor = gl.getUniformLocation(shaderProgramSecondPassBlur, "multiplyColor");

            gl.uniform1f(shaderProgramSecondPassBlur.drawFirstBlurUniform, drawFirstBlur);
            gl.uniform1f(shaderProgramSecondPassBlur.drawFirstBlurCoCUniform, drawFirstBlurCoC);
            gl.uniform1f(shaderProgramSecondPassBlur.drawSecondBlurUniform, drawSecondBlur);
            gl.uniform1f(shaderProgramSecondPassBlur.drawSecondBlurCoCUniform, drawSecondBlurCoC);

            gl.uniform1f(shaderProgramSecondPassBlur.multiplyColor, multiplyColor);

            gl.uniform1f(shaderProgramSecondPassBlur.farBlurdistancelimitUniform, farBlurdistancelimit);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawCoCSizePass() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(shaderProgramCoCSizePass);

            shaderProgramCoCSizePass.vertexPositionAttribute = gl.getAttribLocation(shaderProgramCoCSizePass, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramCoCSizePass.vertexPositionAttribute);

            shaderProgramCoCSizePass.textureCoordAttribute = gl.getAttribLocation(shaderProgramCoCSizePass, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramCoCSizePass.textureCoordAttribute);

            shaderProgramCoCSizePass.samplerUniform0 = gl.getUniformLocation(shaderProgramCoCSizePass, "colorChannel");
            shaderProgramCoCSizePass.samplerUniform1 = gl.getUniformLocation(shaderProgramCoCSizePass, "depthChannel");

            shaderProgramCoCSizePass.CoCScaleUniform = gl.getUniformLocation(shaderProgramCoCSizePass, "CoCScale"); 
            shaderProgramCoCSizePass.CoCBiasUniform = gl.getUniformLocation(shaderProgramCoCSizePass, "CoCBias");

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramCoCSizePass.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramCoCSizePass.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramCoCSizePass.samplerUniform0, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferDepth);
            gl.uniform1i(shaderProgramCoCSizePass.samplerUniform1, 1);

            var zNear = myCamera.GetNearValue();
            var zFar = myCamera.GetFarValue();

            //var CoCScale = (Aperture * focalLength * focalPlane * (zFar - zNear)) / ((focalPlane - focalLength) * zNear * zFar);
            //var CoCBias = (Aperture * focalLength * (zNear - focalPlane)) / (focalPlane - focalLength) * zNear;
            auxFocalPlane = _focalPlane*zFar;

            CoCScale = (Aperture * focalLength * auxFocalPlane * (zFar - zNear)) / ((auxFocalPlane - focalLength) * zNear * zFar);
            CoCBias = (Aperture * focalLength * (zNear - auxFocalPlane)) / ((auxFocalPlane - focalLength) * zNear);

            gl.uniform1f(shaderProgramCoCSizePass.CoCScaleUniform, CoCScale);
            gl.uniform1f(shaderProgramCoCSizePass.CoCBiasUniform, CoCBias);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawApplyDoFPass() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(shaderProgramApplyDoFPass);

            shaderProgramApplyDoFPass.vertexPositionAttribute = gl.getAttribLocation(shaderProgramApplyDoFPass, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramApplyDoFPass.vertexPositionAttribute);

            shaderProgramApplyDoFPass.textureCoordAttribute = gl.getAttribLocation(shaderProgramApplyDoFPass, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramApplyDoFPass.textureCoordAttribute);

            shaderProgramApplyDoFPass.samplerChannel0Uniform = gl.getUniformLocation(shaderProgramApplyDoFPass, "uChannelOriginalScene");
            shaderProgramApplyDoFPass.samplerChannel1Uniform = gl.getUniformLocation(shaderProgramApplyDoFPass, "uChannelBluredScene");


            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramApplyDoFPass.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramApplyDoFPass.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferSetupScene);
            gl.uniform1i(shaderProgramApplyDoFPass.samplerChannel0Uniform, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferApplyDoF);
            gl.uniform1i(shaderProgramApplyDoFPass.samplerChannel1Uniform, 1);


            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function drawDebugPass1() {
            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(shaderProgramDebugPass1);

            shaderProgramDebugPass1.vertexPositionAttribute = gl.getAttribLocation(shaderProgramDebugPass1, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramDebugPass1.vertexPositionAttribute);

            shaderProgramDebugPass1.textureCoordAttribute = gl.getAttribLocation(
                shaderProgramDebugPass1, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramDebugPass1.textureCoordAttribute);

            shaderProgramDebugPass1.samplerUniform = gl.getUniformLocation(shaderProgramDebugPass1, "uSampler");

            shaderProgramDebugPass1.resolutionUniform = gl.getUniformLocation(shaderProgramDebugPass1, "uResolution");

            shaderProgramDebugPass1.bokehStrengthUniform = gl.getUniformLocation(shaderProgramDebugPass1, "bokehStrength");

            shaderProgramDebugPass1.timeUnifom = gl.getUniformLocation(shaderProgramDebugPass1, "uTime");

            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramDebugPass1.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramDebugPass1.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferCoCSize);
            gl.uniform1i(shaderProgramDebugPass1.samplerUniform, 0);

            gl.uniform2f(shaderProgramDebugPass1.resolutionUniform, gl.viewportWidth, gl.viewportHeight);

            gl.uniform1f(shaderProgramDebugPass1.bokehStrengthUniform, bokehStrength);

            gl.uniform1f(shaderProgramDebugPass1.timeUniform, elapsed);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
            gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);        
        }

        function drawDebugPixelCoC(enableBorder) {
            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(shaderProgramDebugCoC);

            shaderProgramDebugCoC.vertexPositionAttribute = gl.getAttribLocation(shaderProgramDebugCoC, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgramDebugCoC.vertexPositionAttribute);

            shaderProgramDebugCoC.textureCoordAttribute = gl.getAttribLocation(shaderProgramDebugCoC, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgramDebugCoC.textureCoordAttribute);


            shaderProgramDebugCoC.samplerUniform = gl.getUniformLocation(shaderProgramDebugCoC, "inputChannel");

            shaderProgramDebugCoC.modelMatrixUniform = gl.getUniformLocation(shaderProgramDebugCoC, "model");

            //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
            gl.disable(gl.DEPTH_TEST);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgramDebugCoC.vertexPositionAttribute, screenFillingVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, screenFillingTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgramDebugCoC.textureCoordAttribute, screenFillingTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureFramebufferCoCSize);
            gl.uniform1i(shaderProgramDebugCoC.samplerUniform, 0);

            mat4.identity(mMatrix);
            var aux = mat4.create();

            mat4.fromScaling(aux, [1.0, 1.0, 1.0]);
            mat4.multiply(mMatrix, mMatrix, aux);

            gl.uniformMatrix4fv(shaderProgramDebugCoC.modelMatrixUniform, false, mMatrix);

            if (enableBorder == 0) {
                gl.uniform1i(gl.getUniformLocation(shaderProgramDebugCoC, "uDrawBorder"), 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
                gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            } else {
                gl.uniform1i(gl.getUniformLocation(shaderProgramDebugCoC, "uDrawBorder"), 1);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
                gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                mat4.fromScaling(aux, [0.97, 0.97, 1.0]);
                mat4.multiply(mMatrix, mMatrix, aux);

                gl.uniformMatrix4fv(shaderProgramDebugCoC.modelMatrixUniform, false, mMatrix);

                gl.uniform1i(gl.getUniformLocation(shaderProgramDebugCoC, "uDrawBorder"), 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, screenFillingIndexBuffer);
                gl.drawElements(gl.TRIANGLES, screenFillingIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            }

            gl.enable(gl.DEPTH_TEST);
        }

        function drawBokehEffects() {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferSetupSceneRGBA32F);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            //drawHDRBokehScene2D(shaderProgramLightingPhong);
            drawScene(shaderProgramLightingPhong);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferDepth);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            drawScene(shaderProgramDepthPass);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferCoCSize);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            drawCoCSizePass();

            gl.bindFramebuffer(gl.FRAMEBUFFER, MRTfbData.f);

            var bufferList = [
                ext3.COLOR_ATTACHMENT0_WEBGL,
                ext3.COLOR_ATTACHMENT1_WEBGL
            ];
            ext3.drawBuffersWEBGL(bufferList);

            drawFirstPassBokeh(0.0);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferApplyDoFPass);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            drawSecondPassBokeh(0.0, 0.0, 0.0, 0.0, 0.0);


            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            //drawScreenTexture(MRTfbData.t[0], 0);
            //gl.viewport(0, 2*gl.viewportHeight/5.0 , gl.viewportWidth/4.0 * 3.0, gl.viewportHeight/5.0*3.0); low canvas version
            gl.viewport(0, 4*gl.viewportHeight/7.0 , gl.viewportWidth/8.0 * 3.0, gl.viewportHeight/7.0*3.0);
            drawApplyDoFPass();

            gl.viewport(3 * (gl.viewportWidth/8.0), 6*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawScreenTexture(textureFramebufferDepth, 1, 0.0, 0.0, 0.0);

            gl.viewport(3 * (gl.viewportWidth/8.0), 5*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawScreenTexture(textureFramebufferSetupScene, 1, 0.0, 0.0, 0.0);

            //drawScreenTexture(textureFramebufferCoCSize, 1, 0.0, 0.0, 0.0);

            gl.viewport(3 * (gl.viewportWidth/8.0), 4*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            //drawScreenTexture(textureFramebufferCoCSize, 1, 0.0, 0.0, 0.0);

            //shaderProgramDebugCoC
            drawDebugPixelCoC(1);
            //drawScreenTexture(textureFramebufferCoCSize, 0.0, 0.0, 0.0, 0.0);

            gl.viewport(0 * (gl.viewportWidth/8.0), 2*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawScreenTexture(MRTfbData.t[0], 1, 0.0, 0.0, 0.0);
            //MRTfbData.t[0]

            gl.viewport(0 * (gl.viewportWidth/8.0), 0*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawScreenTexture(MRTfbData.t[0], 1, 1.0, 0.0, 1.0);


            gl.viewport(2 * (gl.viewportWidth/8.0), 2*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawScreenTexture(MRTfbData.t[1], 1, 0.0, 1.0, 0.0);

            gl.viewport(2 * (gl.viewportWidth/8.0), 0*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawScreenTexture(MRTfbData.t[1], 1, 1.0, 0.0, 1.0);


            gl.viewport(4 * (gl.viewportWidth/8.0), 2*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawSecondPassBokeh(1.0, 0.0, 0.0, 0.0, 0.0);

            gl.viewport(4 * (gl.viewportWidth/8.0), 0*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawSecondPassBokeh(0.0, 1.0, 0.0, 0.0, 1.0);


            gl.viewport(6 * (gl.viewportWidth/8.0), 2*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawSecondPassBokeh(0.0, 0.0, 1.0, 0.0, 0.0);

            gl.viewport(6 * (gl.viewportWidth/8.0), 0*(gl.viewportHeight/7.0), 2*gl.viewportWidth/8.0, 2*gl.viewportHeight/7.0);
            drawSecondPassBokeh(0.0, 0.0, 0.0, 1.0, 1.0);




            gl.viewport(4 * (gl.viewportWidth/8.0), 6*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawDebugPass1(); // Draws focal plane

            gl.viewport(4 * (gl.viewportWidth/8.0), 4*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawScreenTexture(MRTfbData.t[0], 1, 1.0, 0.0, 50.0);

            gl.viewport(5 * (gl.viewportWidth/8.0), 4*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawScreenTexture(MRTfbData.t[1], 1, 1.0, 0.0, 50.0);

            gl.viewport(6 * (gl.viewportWidth/8.0), 4*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawSecondPassBokeh(0.0, 1.0, 0.0, 0.0, 50.0);

            gl.viewport(7 * (gl.viewportWidth/8.0), 4*(gl.viewportHeight/7.0),  gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            drawSecondPassBokeh(0.0, 0.0, 0.0, 1.0, 50.0);


            //gl.viewport(4 * (gl.viewportWidth/8.0), 5*(gl.viewportHeight/7.0), gl.viewportWidth/8.0, gl.viewportHeight/7.0);
            //drawFirstPassBokeh(1.0);


        }

		var currentlyPressedKeys = {};

		function handleKeyDown(event) {
			console.log(event.keyCode);
			currentlyPressedKeys[event.keyCode] = true;
		}

		function handleKeyUp(event) {
			currentlyPressedKeys[event.keyCode] = false;
		}

		//var positionFocalPlane = vec3.fromValues(0.0, 0.0, -450.0);
		var positionFocalPlane = vec3.fromValues(0.0, 0.0, 0.0);

		function handleKeys() {
			
			//positionFocalPlane = 

			// FORWARD
			if (currentlyPressedKeys[87]) {
				//console.log("forward");
				myCamera.ProcessKeyboard(0, deltaTime); // 0 is forward direction
			}
			// BACKWARD
			if (currentlyPressedKeys[83]) {
				myCamera.ProcessKeyboard(1, deltaTime); // 0 is forward direction
			}
			// RIGHT
			if (currentlyPressedKeys[68]) {
				myCamera.ProcessKeyboard(3, deltaTime); // 0 is forward direction
			}
			// LEFT
			if (currentlyPressedKeys[65]) {
				myCamera.ProcessKeyboard(2, deltaTime); // 0 is forward direction
			}
			if (currentlyPressedKeys[27]) {
				enableMouse = !enableMouse;
			}

			if (currentlyPressedKeys[82]) {
				//console.log(distanceFocalPlane);
				distanceFocalPlane += 10;
				uFocalDistance += 10;
			}
			if (currentlyPressedKeys[70]) {
				//console.log(distanceFocalPlane);
				distanceFocalPlane -= 10;
				uFocalDistance -= 10;
			}
            if (currentlyPressedKeys[84]) {
                bokehStrength += 0.1;
            }
            if (currentlyPressedKeys[71]) {
                if (bokehStrength >= 0.01) {
                    bokehStrength -= 0.1;    
                } else {
                    bokehStrength = 0.0;
                }
            }

            if (currentlyPressedKeys[85]) {
                Aperture += 0.01;
            }
            if (currentlyPressedKeys[74]) {
                Aperture -= 0.01;
            }

            if (currentlyPressedKeys[73]) {
                if (_focalPlane < 0.99) {
                    _focalPlane += 0.001;    
                }
            }
            if (currentlyPressedKeys[75]) {
                if (_focalPlane > 0.0) {
                    _focalPlane -= 0.001;
                }
            }

            if (currentlyPressedKeys[79]) {
                focalLength += 0.1;
            }
            if (currentlyPressedKeys[76]) {
                focalLength -= 0.1;
            }

            if (currentlyPressedKeys[89]) {
                farBlurdistancelimit += 0.01;
            }

            if (currentlyPressedKeys[72]) {
                farBlurdistancelimit -= 0.01;
            }
		}

		function handleMouseMove(event) {
			//console.log(event);
			//console.log(event.screenX);
			//console.log(event.screenY);
			if (enableMouse) {
				var xpos = event.clientX;
				var ypos = event.clientY;

				if (firstMouse) {
					lastX = xpos;
					lastY = ypos;
					firstMouse = false;
				}

				var xoffset = xpos - lastX;
				var yoffset = lastY - ypos;	// Reversed since y-coordinates go from bottom to left

				lastX = xpos;
				lastY = ypos;

				//console.log(xoffset);
				//console.log(yoffset);

				myCamera.ProcessMouseMovement(xoffset, yoffset, true);
			}
		}

		function createFramebuffers() {
            var ext = gl.getExtension('OES_texture_float');
            var ext2 = gl.getExtension('OES_texture_float_linear');

			framebufferSetupSceneRGBA32F = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferSetupSceneRGBA32F);

			var texture = createAndSetupTexture();
			textureFramebufferSetupScene = texture;

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);

			var renderbuffer = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);

			
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);



            auxFramebufferRGBA32F = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, auxFramebufferRGBA32F);

            var _texture = createAndSetupTexture();
            textureAuxFramebuffer = _texture;

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);

            var _renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, _renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, _texture, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER,_renderbuffer);



			framebufferFocalDepthScene = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferFocalDepthScene);

			var texture2 = createAndSetupTexture();
			textureFramebufferFocalDepthScene = texture2;

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

			var renderbuffer2 = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer2);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer2);



            framebufferDepth = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferDepth);


            var textureDepth = createAndSetupTexture();
            textureFramebufferDepth = textureDepth;

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);

            var renderbufferDepth = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbufferDepth);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureDepth, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbufferDepth);





            framebufferCoCSize = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferCoCSize);

            var textureCoC = createAndSetupTexture();
            textureFramebufferCoCSize = textureCoC;

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);

            var renderbufferCoC = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbufferCoC);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureCoC, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbufferCoC);
            textureFramebufferCoCSize = textureCoC;




            framebufferApplyDoFPass = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferApplyDoFPass);

            var textureApplyDoF = createAndSetupTexture();
            textureFramebufferApplyDoF = textureApplyDoF;


            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);

            var renderbufferApplyDoF = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbufferApplyDoF);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureApplyDoF, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbufferApplyDoF);




			framebufferBufferABokehRGBA32F = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferABokehRGBA32F);

			var texture3 = createAndSetupTexture();
			textureFramebufferBufferABokeh = texture3;

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture3, 0);


			//B
			framebufferBufferBBokehRGBA32F = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferBBokehRGBA32F);

			var texture4 = createAndSetupTexture();
			textureFramebufferBufferBBokeh = texture4;

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);


			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture4, 0);


			// C
			framebufferBufferCBokehRGBA32F = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferCBokehRGBA32F);

			var texture5 = createAndSetupTexture();
			textureFramebufferBufferCBokeh = texture5;

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);


			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture5, 0);


			// D
			framebufferBufferDBokehRGBA32F = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferBufferDBokehRGBA32F);

			var texture6 = createAndSetupTexture();
			textureFramebufferBufferDBokeh = texture6;

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.FLOAT, null);


			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture6, 0);
		}

        function setupMRT() {
            ext3 = gl.getExtension('WEBGL_draw_buffers');
            if (!ext3) {
                alert("WEBGL_draw_buffers nor supported");
            } else {
                console.log("MAX_COLOR_ATTACHMENTS_WEBGL: "+gl.getParameter(ext3.MAX_COLOR_ATTACHMENTS_WEBGL));
                console.log("MAX_DRAW_BUFFERS_WEBGL: " + gl.getParameter(ext3.MAX_DRAW_BUFFERS_WEBGL));

                MRTfbData = create_framebuffer_MRT(gl.viewportWidth, gl.viewportHeight);
            }
        }

        function create_framebuffer_MRT(width, height) {
            var ext = gl.getExtension('OES_texture_float');
            var ext2 = gl.getExtension('OES_texture_float_linear');

            var frameBuffer = gl.createFramebuffer();

            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

            var fTexture = [];

            for (var i = 0; i < 2; ++i) {
                fTexture[i] = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, fTexture[i]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                gl.framebufferTexture2D(gl.FRAMEBUFFER, ext3.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, fTexture[i], 0);
            }

            var depthRenderBuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);

            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return {
                f: frameBuffer,
                d: depthRenderBuffer,
                t: fTexture
            };
        }

        function initSphereObject() {
            sphereGeomParams = uvSphere(0.6,64,32);
            console.log("SPHERE GEOM COMPUTED");
        }

		function webGLStart() {
			var canvas = document.getElementById("3D_scene-canvas");
			initGL(canvas);

			initShadersFocalPlane();
			initShadersDepth();
			initShadersFocalDepth();
			initTextures();
			initCamera();


            initShaderLightingPhong();

            initShadersRendToText();
            initShadersDepthObjectSpace();

			//initShaderBufferA();
			//initshaderBufferB();
			//initshaderBufferC();
			//initshaderBufferD();

			//initShaderBufferImage();
			initScreenFillingBuffers();

            //initShadersFirstPassOpticalBokehVertical();
            //initShadersFirstPassOpticalBokehDiagonal();
            //initShadersSecondPassOpticalBokehDiagonalLeft();
            //initShadersSecondPassOpticalBokehDiagonalRight();
            //initShadersFirstPassCombined();
            //initShadersBokehCombinedPasses();

            //initShadersHdrColor();

			createFramebuffers();

            debugSorting();

			init3DScene();
			//loadTeapot();

            setupMRT();
            initShadersFirstPassBlur();
            initShadersSecondPassBlur();

            initShadersDepthPass();
            initShadersCoCSizePass();

            initShadersApplyDoFPass();

            initShadersDebugCoC();

            initShadersDebugPass1();

			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.enable(gl.DEPTH_TEST);

			time_start = new Date().getTime();

			document.onkeydown = handleKeyDown;
			document.onkeyup = handleKeyUp;
			document.onmousemove = handleMouseMove;

            initStatistics();

			tick();
		}


		</script>

	</head>

	<body onload="webGLStart();">
        <div class="container">
            <canvas id="3D_scene-canvas" style="border: none;" width="2100" height="1200"></canvas> 
		    <!-- <canvas id="3D_scene-canvas" style="border: none;" width="3200" height="1680"></canvas> -->
            <div id="overlay">
                <div>FPS: <span id="time"></span></div>
                <div>Aperture: <span id="aperture"></span></div>
                <div>Focal Plane: <span id="focalplane"></span></div>
                <div>Focal Length: <span id="focallength"></span></div>
                <div>CoCScale: <span id="cocscale"></span></div>
                <div>CoCBias: <span id="cocbias"></span></div>
                <div>CoCScale + CoCBias: <span id="cocdiff"></span></div>
                <div>Bokeh Strength: <span id="bokehstrength"></span></div>
                <div>Far Blur Distance Limit: <span id="farblurdistancelimit"></span></div>
            </div>
        </div>
	</body>
</html>